一、Session
    session.save(对象)
    session.delete(对象)
    session.load(Student.class, 1);//是会延时加载
    session.get(Student.class, 1);//不会延时加载
    session.update(对象)
        1. 用来更新离线(detached)对象，更新完成后转为persistent状态
        2. 更新瞬时(transient)对象会报错
        3. 持久化(persistent)状态的对象只要设定不同字段就会发生更新
    session.flush();
        1. 当session的事务提交后,会强制将内存(session缓存)与数据库同步。

二、Query查询接口
    HQL:
        步骤一：获得Query对象：Query query=s.createQuery(“HQL语句”);
        步骤二：为参数赋值：query.setXXX();
        步骤三：获得List对象：LIST list=query.list(); 说明，除了此方法外，Query
                接口还有一个常用的方法uniqueResult，如果明确查询的结果只有一个，便选择使用此方法。如果查询结果有多个使用此方法会报异常。
    QBC:
        步骤一： 获得Criteria对象：Criteria criteria = s.createCriteria(User.class);
        步骤二： 封装查询条件为一个Criterion对象：Criterion cr = Expression.eq("name", "new name");
                 或者 Criterion cr=Restrictions.eq("name","new name");
        步骤三： 获得带查询条件的Criteria对象：criteria.add(cr); 执行此步才使这个对象具有一个条件限制的查询操作。
        步骤四: List clist = criteria.list(); 也可以直接返回一个User对象：User user=(User) criteria.uniqueResult();

三、关系映射
    1、多对一 : 一个部门有可以有多个员工，而一个员工只属于一个部门

    public class Department {
        private int id;
        private String name;

        public int  getId() {   return id;   }
        public void setId(int id) {   this.id = id;  }

        public String getName() { return name;  }
        public void setName(String name) {  this.name = name; }
    }









