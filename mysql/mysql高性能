第一章
MYSQL 架构
一 逻辑结构
1 连接管理和安全性 : 每个客户端连接都会在服务器进程中拥有一个线程,当客户端连接到Mysql服务器时,服务器需要对其进行认证
2 优化与执行 : mysql会解析查询,并创建内部解析树,然后对其进行各种优化,包括重写查询,决定表的读写顺序,以及选择合适的索引.
mysql查询缓存,如果查询缓存有结果集,服务器就不必再执行查询解析,优化和执行的整个过程,而是直接返回查询缓存的结果集

二 并发控制 mysql并发控制两个层面:服务器层和存储引擎层
1 读写锁
在并发读或者写时,可以通过实现一个由两中类型的锁组成的锁系统来解决问题,这两种类型的锁通常被称为共享锁(读锁)和排他锁(写锁)
读锁是共享的,或者说是互相不阻塞的.写锁是排他,会阻塞写锁和读锁

2 锁粒度 : (Mysql存储引擎可以实现自己的锁策略和锁粒度)
表锁 : 会锁定整张表,一个用户在对表进行写操作前,先获得写锁,这会阻塞其他用户对该表的所有读写操作(服务器和存储引擎层面)

行锁 : 可以最大程度支持高并发,在InnoDB以及其他存储引擎实现了行级锁.行级锁只在存储引擎层实现,而在Mysql服务器层没有实现,服务器完全不了解存储引擎中的锁实现

3 事务: 事务内的sql语句,要么全部执行成功,要么全部执行失败
原子性 : 一个事务必须被视为一个不可分割的最小工作单元
一致性 : 从一个一致性的状态转换到另一个一致性的状态
隔离性 : 一个事务所做的修改在最终提交前,对其他事务是不可见的
持久性 : 一但事务提交,保持数据库中
有些存储引擎支持事务,有些不支持,对于不需要事务的,选择一个非事务性的存储引擎,可以获得更高的性能

1 隔离级别
未提交读 : 从产出脏读
提交读 : 一个事务从开始直到提交前,所做的任何修改对其他事务都是不可见的(但会造程两次读取,结果不一致)
Mysql默认(可重复读) :
可以重复读取，但有幻读。读写观点：读取的数据行不可写，但是可以往表中新增数据。在MySQL中，其他事务新增的数据，看不到，不会产生幻读。采用多版本并发控制（MVCC）机制解决幻读问题。
可串行话 : 最高级别,性能较低
select @@tx_isolation; 用来查看事务隔离级别

2 死锁 两个事务得到锁的顺序不一致
数据库系统实现了各种死锁检查和死锁超时机制.
innodb处理死锁的方式: 将持有最小行级锁的事务回滚

锁的行为和顺序是和存储引擎相关的,以同样的顺序执行语句,有些存储引擎会产生死锁.

3 Mysql中的事务
两种事务型存储引擎: Innodb和NDBCluster
自动提交: 查看事务提交模式 show variables like 'autocommit'
这个autocommit值,不会对MyISAM有任务影响
注意:尽量不要在事务中混合使用事务型和非事务型表

4 隐式锁定和显式锁定
隐式 : Innodb会根据隔离级别在需要的时候自动加锁
显示 : innodb
select ... Lock in share mode 手动加行级共享锁
select ... For update 手动加行级排他锁

5 多版本并发控制
MVCC是行级锁变来,但是他在很多情况下避免了加锁,因此开销低.虽然实现机制有所不同,但大多实现了非阻塞的读操作,写操作也只锁定必要的行
MVCC分为: 乐观和悲观
Innodb的MVCC
每开始一个新的事务,系统版本号都会自动递增,事务开始时的系统版本号会作为事务的版本号,用来和查询到的每行记录的版本号比较.
MVCC只在Repeatable和Committed两个隔离级别下工作.

6 Mysql的存储引擎
在文件系统汇中,mysql将每个数据库保存为数据目录下的一个子目录,创建表时,Mysql会在数据库子目录下创建一个和表同名的.frm文件保存表的定义
通过:show table status like 'reading_book'

(1) Innodb存储引擎 : 是Mysql的默认事务型引擎
Innodb的数据存储在表空间中,表空间是由一系列的数据文件组成,Innodb可以将每个表的数据和索引放在单独的文件中.
Innodb可以将每个表的数据和索引存放在单独的文件中

Innodb采用mvcc来支持高并发,并且实现了四个标准的隔离级别.其默认级别是repeatable table,并且通过间隙锁策略防止幻读
间隙锁使得innodb不仅仅锁定查询涉及的行,还会对索引中的间隙进行锁定.

Innodb是基于聚簇索引建立的,Innodb的索引结构和mysql的其他存储引擎有很大的不同,聚簇索引对主键查询有很高的性能,不过它的二级索引中必须包含主键例

Innodb内部做了很多优化,包括从磁盘读取数据时,能够在内存中创建hash索引加速读操作,以及能够加速插入操作的缓冲区

Innodb通过一些机制和工具支持真正的热备份

(2) MyISAM 存储引擎
MyISAM提供了大量的特性,包括全文索引,压缩,空间函数等,但MyISAM不支持事务和行级锁,而且无法恢复

MyISAM会将表存储在两个文件中,数据文件和索引文件,分别.MYD和.MYI为扩展名

MyISAM特性
加锁与并发: MyISAM对整张表加锁,而不是针对行
读取时会对需要读到的所有表加共享锁,写入时则对表加排他锁.但是在表有读取查询的同时,也可以往表中插入新的记录

索引特性: 对于BLOB和Text等长字段,也可以基于其前500个字符创建索引.MyISAM也支持全文索引,这是一种基于分词创建的索引,可以支持复杂的查询.
延迟更新索引建 :

MyISAM压缩表: 如果表创建并导入数据后,不会再进行修改操作,这样的表合适采用MyISAM压缩表
压缩表减少空间占用,从而提高查询性能,压缩表支持索引,索引是只读的

MyISAM最大的性能缺点: 会锁表

7 选择合适的引擎
切换存储引擎:
方法一:ALTER TABLE mytable ENGING = InnoDB
方法二:导出和导入
方法三:

第四章 Schema与数据类型优化(逻辑设计)
一 选择优化的数据类型
更小的通常更好 更小的数据类型通常更快,因为它们占用更少的磁盘,处理时间也会少.
简单数据类型的操作通常需要更少的cpu周期.因为字符集和校对规则使字符比较比整型比较更复杂
    使用mysql内建的类型而不是字符串来存储日期和时间
    使用整型存储ip地址
    使用到的两个mysql函数:IP转数字函数inet_aton(),数字转IP函数inet_ntoa()
尽量避免使用null值
    如果包含为null的列,mysql来说更难优化,因为可为null的列使用索引比较复杂.并且null的列会使用更多的存储空间
mysql中很多数据类型可以存储相同的数据,只是存储的长度和范围不一样.

1 整数类型
注意: INT(1)和INT(20)不会限制值的合法范围

2 实数类型
FLOAT DOUBLE 和 DECIMAL

3 字符串类型

4 VARCHAR和CHAR类型 : 存储与存储引擎有关
(1) VARCHAR 类型用于存储可变长字符串,它比定长类型更节省空间,因为它仅使用必要的空间
VARCHAR需要使用1或者2个额外字节记录字符串的长度,如果列的最大长度小于或等于255,则使用1个字节表示,否则使用2个字节
VARCHAR节省了存储空间,所以对性能也有帮助.如果一个行占用的空间增加,并且在页内没有更多的空间可以存储,在这种情况,不同的存储引擎处理的方式不一样
MyISAM会将行拆成不同的片段,InnoDB需要分裂页来使行可以放进页内
注意InnoDB会把过长的Varchar存储为BLOB

(2) CHAR 类型使定长的 Mysql总是根据定义的字符串长度分配足够的空间
CHAR不易产生碎片,合适存储密码的MD5值,因为这是一个定长的值
CHAR会删除末尾的空格

5 BLOB和TEXT类型 : 大的字符串类型
Mysql把每个BLOB和TEXT值当作一个独立的对象处理.
当BLOB和TEXT值太大时,Innodb会使用"外部存储区域来进行存储"
BLOB和TEXT区别: BLOB是存储二进制,没有排序规则或字符集,而TEXT类型有字符集和排序规则
Mysql不能将BLOB和TEXT列的全部长度的字符串进行索引

6 使用枚举ENUM代替字符串类型 : 优点数据存储紧凑
create table enum_test(e ENUM('fish','apple','dog') not null );s
insert into enum_test(e) values ('apple'),('fish'), ('dog');

7 日期和时间类型
例如DATETIME和TIMESAMP都可以存储相同类型的数据,都是TIMESAMP只使用DATETIME一半的空间

8 位数据类型
BIT
create table bittest (a bit(8));
insert into bittest values(b'00111001');
select a from bittest 结果57

SET
create table acl_test ( perms set ('can_read','can_write','can_delete') not null);
insert into acl_test(perms) values ('can_read','can_delete');

9 选择标示符 : 为标示符选择数据类型时,应该选择跟关联表中的对应列一样的类型
当选择标示列的类型时,在可以满足值的范围需求时,应选最小的数据类型.比如TINYINT足够存储,而且比INT小,用这样作为其他表的外键.可能导致很大的性能差异
不要使用Enum和SET作为标示符

二 Mysql表设计的陷阱
1 太多的列
Mysql的存储引擎API工作时需要服务器层和存储引擎层之间通过行缓冲格式拷贝数据,然后在服务器层将缓冲内容解码成各个列
2 太多的关联
如果希望查询执行得快速并且并发好,单个查询最好在12个表以内做关联
3 全能的枚举
防止过度的使用枚举
4 变相的枚举
5 NUll: 避免使用空值
create table t1(dt datetime not null default '0000-00-00 00:00:00')


三 范式和反范式
1 范式的优点和缺点
优点 : 只有很少或者没有重复数据;表通常比较小,可以更好地放在内存里,所以执行比较快;使用DISTINCT和GROUP BY语句
缺点 : 需要关联

2 反范式的优点和缺点
优点 : 不需要关联表;也能使用更有效的索引策略
缺点 : 重复数据比较多

四 缓存表和汇总表
1 物化视图 : 预先计算并且存储在磁盘上的表,可以通过各种各样的策略刷新和更新
mysql 通过第三方开源工具可以实现物化视图

2 计算器表 : 可以用这种表缓存一个用户的朋友数,文件下载次数等

五 ALTER TABLE
对常见的场景,能使用的技巧有两种
1 先在一台不提供服务的机器上执行ALTER TABLE操作,然后和提供服务的主库切换
2 影子拷贝: 是用要求的表结构创建一张新表,然后通过重命名和删表操作交换两张表

ALTER TABLE film MODIFY COLUMN duration TINYINT(3) NOT NULL DEFAULT 5; 会重建表
ALTER TABLE film ALTER COLUMN duration SET DEFAULT 5; 效率高,因为直接.frm

(1)只修改.frm文件
从上面的列子我们看到修改表的.frm文件是很快的,但Mysql有时候会在没有必要的时候也重键表
(2) 快速创建MyISAM索引

第五章 创建高性能的索引
索引是存储引擎用于快速找到记录的一种数据结构,这是索引的基本功能,除此之外,本章还将讨论索引其他一些方面有用的属性

1 索引基础
存储引擎先在索引中找到对应值,然后根据匹配的索引记录找到对应的数据行.
索引可以包含一个或多个列的值,如果索引包含多个列,那么列的顺序也十分重要,因为Mysql只能高效地使用索引的最左前缀列

(1)索引类型
索引是在存储引擎层而不是服务器层实现的.
没有统一的索引标准 : 不同存储引擎的索引的工作方式并不一样,也不是所有的存储引擎支持所有类型的索引
即使不同的存储引擎支持同一种类型的索引,其底层的实现也可能不同

B-Tree索引(默认索引)
存储引擎以不同的方式使用B-Tree索引,性能各有不同.
Myisam使用前缀压缩技术使得索引更小,但Innodb则按照原数据格式进行存储.
Myisam索引通过数据的物理位置引用被索引的行,而Innodb则根据主键引用被索引的行

B-Tree是平衡树意味着所有的值都是按顺序存储的
存储引擎不再需要进行全表扫描来获取需要的数据,而是从索引的根节点开始查找,向下查找子节点,然后找到根结点(从而找到指向被索引的数据)
B-Tree适合范围查找

索引对多个值进行排序的依据是建表语句中定义索引是列的顺序.

B-Tree索引的查询类型 : 适用于全键值,键值范围,键前缀查找
1 全值匹配指的是和索引中的所有列进行匹配
2 匹配最左前缀 : 只使用索引按顺序前面的列
3 匹配列前缀 : 只匹配某一列值开头的部分
4 匹配范围值 :
5 可以精确匹配第一列范围匹配另外一列(只能有一个范围)
6 覆盖索引
索引还可以用于查询中的order by操作. 一般来说,如果B-tree可以按照某种方式查找到值,那么也可以按照这种方式用于排序

哈希索引
只能精确匹配索引所有列的查询才有效
哈希索引将所有的哈希吗存储在索引中,同时在哈希表中保存指向每个数据行的指针
Memory引擎表的默认索引类型,并且只有Memory支持
哈希索引限制
哈希索引只包括哈希值和行指针,而不存储字段值,所以必须读行
不支持排序
多个字段的索引,必须全部匹配
只支持等值比较
哈希冲突
注意当创建自定义哈希索引时 : 必须在where条件中带上哈希值和对应列值

空间数据索引
MyISAM表支持空间索引,不需要前缀查询,空间索引会从所有维度来索引数据.查询时,可以使用任意维度组合,但必须使用GIS相关函数来维护数据

全文索引是一种特殊类型的索引,查找文本中的关键词,而不是直接比较索引中的值




































