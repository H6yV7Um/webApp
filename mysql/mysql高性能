第一章
MYSQL 架构
一 逻辑结构
1 连接管理和安全性 : 每个客户端连接都会在服务器进程中拥有一个线程,当客户端连接到Mysql服务器时,服务器需要对其进行认证
2 优化与执行 : mysql会解析查询,并创建内部解析树,然后对其进行各种优化,包括重写查询,决定表的读写顺序,以及选择合适的索引.
mysql查询缓存,如果查询缓存有结果集,服务器就不必再执行查询解析,优化和执行的整个过程,而是直接返回查询缓存的结果集

二 并发控制 mysql并发控制两个层面:服务器层和存储引擎层
1 读写锁
在并发读或者写时,可以通过实现一个由两中类型的锁组成的锁系统来解决问题,这两种类型的锁通常被称为共享锁(读锁)和排他锁(写锁)
读锁是共享的,或者说是互相不阻塞的.写锁是排他,会阻塞写锁和读锁

2 锁粒度 : (Mysql存储引擎可以实现自己的锁策略和锁粒度)
表锁 : 会锁定整张表,一个用户在对表进行写操作前,先获得写锁,这会阻塞其他用户对该表的所有读写操作(服务器和存储引擎层面)

行锁 : 可以最大程度支持高并发,在InnoDB以及其他存储引擎实现了行级锁.行级锁只在存储引擎层实现,而在Mysql服务器层没有实现,服务器完全不了解存储引擎中的锁实现

3 事务: 事务内的sql语句,要么全部执行成功,要么全部执行失败
原子性 : 一个事务必须被视为一个不可分割的最小工作单元
一致性 : 从一个一致性的状态转换到另一个一致性的状态
隔离性 : 一个事务所做的修改在最终提交前,对其他事务是不可见的
持久性 : 一但事务提交,保持数据库中
有些存储引擎支持事务,有些不支持,对于不需要事务的,选择一个非事务性的存储引擎,可以获得更高的性能

1 隔离级别
未提交读 : 从产出脏读
提交读 : 一个事务从开始直到提交前,所做的任何修改对其他事务都是不可见的(但会造程两次读取,结果不一致)
Mysql默认(可重复读) :
可以重复读取，但有幻读。读写观点：读取的数据行不可写，但是可以往表中新增数据。在MySQL中，其他事务新增的数据，看不到，不会产生幻读。采用多版本并发控制（MVCC）机制解决幻读问题。
可串行话 : 最高级别,性能较低
select @@tx_isolation; 用来查看事务隔离级别

2 死锁 两个事务得到锁的顺序不一致
数据库系统实现了各种死锁检查和死锁超时机制.
innodb处理死锁的方式: 将持有最小行级锁的事务回滚

锁的行为和顺序是和存储引擎相关的,以同样的顺序执行语句,有些存储引擎会产生死锁.

3 Mysql中的事务
两种事务型存储引擎: Innodb和NDBCluster
自动提交: 查看事务提交模式 show variables like 'autocommit'
这个autocommit值,不会对MyISAM有任务影响
注意:尽量不要在事务中混合使用事务型和非事务型表

4 隐式锁定和显式锁定
隐式 : Innodb会根据隔离级别在需要的时候自动加锁
显示 : innodb
select ... Lock in share mode 手动加行级共享锁
select ... For update 手动加行级排他锁

5 多版本并发控制
MVCC是行级锁变来,但是他在很多情况下避免了加锁,因此开销低.虽然实现机制有所不同,但大多实现了非阻塞的读操作,写操作也只锁定必要的行
MVCC分为: 乐观和悲观
Innodb的MVCC
每开始一个新的事务,系统版本号都会自动递增,事务开始时的系统版本号会作为事务的版本号,用来和查询到的每行记录的版本号比较.
MVCC只在Repeatable和Committed两个隔离级别下工作.









