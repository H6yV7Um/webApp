mysql索引
总结：
选择优化的数据类型
1： 更小的通常更好
2： 简单就好
3： 尽量避免NULL

缓存表和汇总表： 为了提高性能，创建一张完全独立的汇总表或缓存表

物化视图 ：预先计算并存储在磁盘上的表，可以通过各种各样的策略刷新和更新

alter table 优化：
避免执行需要好长时间，可以通过2种技巧
1: 先在一台不提供服务的机器上执行alter table，然后和提供服务的主库切换
2: 创建一张和源表无关的新表，然后通过重命名和删表操作交换两张表
只修改默认值的时候
1: alter table film modify column a tinyint(3) not null default 5
2: alter table film alter column a set default 5 (效率高)

mysql 中包含的索引类型
b-tree 索引
哈希 索引
空间数据 索引
全文 索引

一、 单列索引和多列索引
mysql 在查询是只能使用一个索引，如何有多个单列索引，mysql会试图选择一个最严格的索引，但没有多列够成的索引限制能力强。

二、  最左前缀
如 ： index (col1,col2,col3)
则： 下面三种，都可以使用到索引
         col1,col2,col3
         col1,col2
         col1

三、前缀索引和索引选择性
 1： 索引选择性， 不重复的索引值  /  数据表的记录总数

四、索引顺序
 1： 将选择性最高的列放到索引最前面,当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。

五、聚簇索引
1： 聚簇索引并不是一种单独的索引类型，而是一种数据存储方式，正式聚簇索引的顺序就是数据的物理存储顺序，所以一个表最多只能有一个聚簇索引，因为物理存储只能有一个顺序，一个表只能有一个聚簇索引。
优点： 可以把索引和相关数据保存在一起，数据访问块
缺点： 插入速度依赖于插入顺序，更新会强制InnoDB将每个被更新的行移动到新的位置

六、覆盖索引
1： 根据查询的where条件来创建合适的索引，不过这只是索引优化的一个方面。

如果一个索引包含所有需要查询的字段的值，我们就称之为“覆盖索引”,这样的话，只需要返回扫描索引，而无需在扫描数据行。


七、Mysql 实现排序的两种方式
设计索引时应该尽可能地同时满足排序、查找行

规则
    1: 只有当索引的列顺序和Order by子句的顺序完全一致，并且所有列的排序方向都一样时，Mysql才能够使用索引来对结果做排序。
    2：当需要关联多张表，则order by 子句引用的字段全部为第一表时，才能使用索引做排序。
    3： 需要满足索引的最左前缀。

八、B+树索引和哈希索引
    1:如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；
但如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；
    2:不支持范围查询
    3:哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；
    4:哈希索引也不支持多列联合索引的最左匹配规则；
    5:B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题

