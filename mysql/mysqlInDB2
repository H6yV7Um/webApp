第四章 表

1、索引组织表
    InnoDB表都是根据主键顺序组织存放的,会自动创建主键
        1: 首先判断表中是否有非空的唯一索引，如果有，则该列即为主键 : Unique Key(col)
        2：不符合上述条件，InnoDB存储引擎自动创建一个6字节大小的指针

2、InnoDB逻辑存储结构
    (1) 表空间可以看做事InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。
        Tablespace -> Segment段 -> Extent区 -> Page页 -> Row 行
        共享表空间可以存放：回滚信息，插入缓冲索引页，系统事务信息，二次写缓冲等还是存放在原来的共享表空间内。
        用户表空间只能存放：数据、索引、插入缓冲Bitmap页.
    (2) 段：数据段，索引段，回滚段
    (3) 区：区是由连续也组成的空间，每个区的大小都为1MB
    (4) 页：InnoDB磁盘管理的最小单位
    (5) 行: 每个页存放的行记录也是有硬性定义的，最多8KB记录

3、InnoDB行记录格式
    查看行记录格式 show table status like '表名'
   (1) row_format： 行记录格式（Compact 和 Redundant）
       Compact是5.1以上版本默认
   (2) 行溢出数据：InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。一般认为BLOB、LOB这类的
       大对象列类型的存储会把数据放在数据页面之外。
       注意：mysql数据库varchar类型，字符类型是Latin1,最大长度为65532字节。但varchar类型会转为Text类型
             如果是多个列，是所有列增加起来是65532字节。
             varchar类型：长度小于8098时，插入两行记录，是数据都是在数据页中。但是大于的话就会BLOB页中
             结论，若一个数据页可存储两条记录，则不会发现行溢出.
   (3) Compressed和Dynamic 行记录格式(row_format)

   (4)CHAR的行结构存储
       通常理解varchar是存储变长长度的字符类型，char是存储固定长度的字符类型。
       CHAR(N)中的N指的是字符长度，而不是之前版本的字节长度。也就说在不同的字符集下，CHAR类型列内部存储的可能不是定长的数据。

4、InnoDB数据页结构 : 页是InnoDB存储引擎管理数据库的最小磁盘单位。
   页类型为B-tree Node的页存放的是表中行的实际数据了。

    InnoDB数据页由以下7个部分组成
    File Header（文件头）、Page Header（页头）、Infimun、User Record（用户记录）、Free Space（空闲空间）
    Page Directory（页目录）、File Trailer（文件结尾信息）
    (1) File Header,Page Header,File Trailer : 这些空间用来记录该页的一些信息。
    (2) User Record,Free Space,Page Directory : 这些部分为实际的行记录存储空间。

5、Named File Formats机制 ： 解决不同版本页结构兼容性的问题。

6、约束
(1) 数据完整性 : 关系型数据库系统和文件系统的不同点是，关系数据库本身能保证存储数据的完整性，不需要应用程序的控制。
    而文件系统一般需要在程序段进行控制。数据完整性有以下三种形式：
    （a）实体完整性保证表中有一个主键。
         在InnoDB存储引擎表中，用户可以通过定义Primary Key 或 Unique Key约束来保证实体的完整性。
    （b）域完整性保证数据每列的值满足特定的条件。以下几种方式可以保证
         选择合适的数据类型确保一个数据值满足特定条件。
         外键约束
         编写触发器
         用DEFAULT约束作为强制域完整性的一个方面
     (c) 参照完整性保证两张表之间的关系。InnoDB存储引擎支持外键，因此允许用户定义外键以强制参照完整性，也可以通过编写触发器以强制执行。

(2) 约束的创建和查找
    约束的创建可以采用以下两张方式：表建立时就进行约束定义，利用ALTER TABLE命令来进行创建约束
    查看表的约束：
    select constraint_name , constraint_type from information_schema.TABLE_CONSTRAINTS
    where table_name = 'reading_book'

(3) 约束和索引的区别
    注意 当用户创建了一个唯一索引就创建了一个唯一的约束。但是约束和索引的概念还是不同的，约束更是一个逻辑的概念，用来保证数据的完整性
    而索引是一个数据结构，既有逻辑上的概念，在数据库中还代表物理存储的方式。

    在 MySQL中的key是同时具有constraint和index的意义 : 例如
    primary key
        有两个作用，一是约束作用（constraint），用来规范一个存储主键和唯一性，但同时也在此key上建立了一个index；
    unique key
        也有两个作用，一是约束作用（constraint），规范数据的唯一性，但同时也在这个key上建立了一个index；
    foreign key
        也有两个作用，一是约束作用（constraint），规范数据的引用完整性，但同时也在这个key上建立了一个index；


(4) 对错误数据的约束 : MYSQL数据库允许非法的或不正确的数据的插入或更新，又或者可以在数据库内部将其转化为一个合法的值

(5) Enum 和 Set约束 : MYSQL数据库不支持传统的CHECK约束，但是通过ENUM和SET类型可以解决部分这样的约束需求。
    例如：
    CREATE TABLE a(
        id int,
        sex enum('male','female');
    )
    并且 SET sql_mode = 'STRICT_TRANS_TABLES'
    通过这样的方式可以保证：只能插入'male','female'

(6) 触发器与约束
    完整性约束可以使用触发器来实现
    一个Mysql表最多可以建立6个触发器，并且Mysql只支持行级触发器

(7) 外键约束 : Myisam存储引擎本身并不支持外键。而InnoDB存储引擎支持完整的外键约束

7 视图： 视图是一个命名的虚表，不存储数据的 。作用：它是一个抽象的模型，不需要关系基表的结构，按照视图的定义就可以获取/更新数据
  Mysql实现物化视图：
  (1) ON DEMAND 物化视图：定义一个表_MV表
      Insert into Orders_MV
            select product_name,sum(price),sum(amount),avg(price) from orders group by product_name
      然后每次使用时，都把表清空，重新导入数据即可。
  (2) ON COMMIT 物化视图
      必须创建触发器 ; 对表进行操作

8 分区表 : MYSQL数据库分区将一个表或索引分解为更小的单元，只支持水平分区。
对于一般的oltp应用都不用分区。分区适合olap

第五章 索引与算法

1、InnoDB存储引擎索引概述
B+树索引 : B+树索引能找到的只是被查找数据行所在的页，然后数据库通过把页读入到内存，再在内存中进行查找
当插入/删除一个新的键值的时候，会保证还是一个B+树（平衡树）
通过二分查找法进行查找

聚集索引和辅助索引的区别：叶子节点存放的是否是一整行的信息
(1) 聚集索引：就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页
    表中数据按照主键顺序存放，聚集索引就是按照每张表的主键构造一个B+树。同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。
    由于数据页只能按照一棵B+进行顺序，每张表只能有一个聚簇索引
(2) 辅助索引：不包含行记录数据，通过辅助索引来寻找数据时，会先获得主键，再通过主键找到记录
    可以创建多个B+树，这些B+树都会通过指针指向聚簇索引

(3) 查看索引：
    show INDEX from reading_book

    包含一个重要字段：通过Cardinality值查看索引是否具有高选择性

    alter table t add key idx(a,c); 创建联合索引

(4) B+树索引的使用
    为什么联合索引，要从最左匹配，因为构建的B+排序都是从左开始的
    注意：Extra选项中可以看到Using filesort，需要一次额外的排序才能完成查询。

    覆盖索引： 从辅助索引中可以得到查询的记录，而不需要查询聚集索引中的记录。使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息。减小IO操作。
    (MySQL只需要通过索引就可以返回查询所需要的数据，而不必在查到索引之后进行回表操作)
    Extra看到Using index使用覆盖索引操作

    索引提示：可以显示让优化器使用哪个索引。
    例子
    Create table t(
        a int,
        b int,
        key (a),
        key (b)
    )engine = innodb;

    select  * from t where a = 1 and b = 2  Extra提示：Using intersect(b,a) 表示根据两个索引得到的结果进行求交运算
    强制使用一个索引： select * from force index(a) where a = 1 and b =2

全文检查：倒排索引来实现 (存储了单词与单词自身在一个或多个文档所在位置之间的映射)

哈希索引 : 是自适应的，InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引
哈希算法 :
自适应哈希索引：是mysql数据库自己创建的
查询哈希索引 show engine innodb status




































