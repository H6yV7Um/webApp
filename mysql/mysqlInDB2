第四章 表

1、索引组织表
    InnoDB表都是根据主键顺序组织存放的,这种存储方式的表称为索引组织表。
        在没有主键的时候，会自动创建主键
        1: 首先判断表中是否有非空的唯一索引，如果有，则该列即为主键 : Unique Key(col)
        2：不符合上述条件，InnoDB存储引擎自动创建一个6字节大小的指针

2、InnoDB逻辑存储结构
    Tablespace(表空间) -> Segment段 -> Extent区 -> Page页 -> Row 行
    (1) 表空间可以看作为InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。
        共享表空间可以存放：回滚信息，插入缓冲索引页，系统事务信息，二次写缓冲等还是存放在原来的共享表空间内。
        用户表空间只能存放：数据、索引、插入缓冲Bitmap页.

    (2) 段：数据段，索引段，回滚段
        数据段是B+树的叶子节点
        索引段是B+树的非叶子节点

    (3) 区：区是由连续也组成的空间，每个区的大小都为1MB
        为了保证区中页的连续性，innnoDB存储引擎一次从磁盘申请5-6个区，每个区都有64个连续的页
        （分区表是不是就是使用区这个概念，因为数据是连续的，所以每次都可以查出指定的区）

    (4) 页：InnoDB磁盘管理的最小单位,每个页16KB数据
        页的类型:
        1、数据页
        2、undo页
        3、系统页
        4、事务数据页
        5、插入缓冲位图页
        6、插入缓冲空闲列表页
        7、未压缩的二进制大对象页
        8、压缩的二进制大对象页

    (5) 行: 每个页存放的行记录也是有硬性定义的，最多8KB记录

3、InnoDB行记录格式 : 查看行记录格式 show table status like '表名'
   (1) row_format： 行记录格式（Compact 和 Redundant）
       Compact是5.1以上版本默认

   (2) 行溢出数据： InnoDB存储引擎可以将一条记录中的某些数据存储在真正的"数据页"之外。
       一般认为BLOB、LOB这类的大对象列类型的存储会把数据放在数据页面之外。varchar也可能出现行溢出
       主要Varchar研究：
             mysql数据库varchar类型，字符过长的话，varchar类型会转为Text类型。
             mysql数据库varchar类型，所有列的长度总和不能超出65532这个长度。
             varchar类型：长度小于"8098"时，插入两行记录，是数据都是在"数据页"中。但是大于的话就会BLOB页中。

   (3) Compressed和Dynamic 行记录格式(row_format)

   (4)CHAR的行结构存储
       通常理解Varchar是存储变长长度的字符类型，Char是存储固定长度的字符类型。
       CHAR(N)中的N指的是字符长度，也就说在不同的字符集下，CHAR类型列内部存储的可能不是定长的数据。
       例如：UTF-8下CHAR（10）类型的列，其最小可以存储10字节的字符，而最大可以存储30字节的字符。

4、InnoDB数据页结构 : "B-tree Node"类型的页存放的是表中行的实际数据了。
    InnoDB数据页由以下7个部分组成
    文件头、
    页头、
    用户记录、
    空闲空间
    页目录、
    文件结尾信息
    (1) 文件头,页头,文件结尾的大小是固定的 : 这些空间用来记录该页的一些信息。
    (2) 用户记录,空闲空间,页目录 : 这些部分为实际的行记录存储空间。大小动态的

5、Named File Formats机制 ： 解决不同版本页结构兼容性的问题。

6、约束
(1) 数据完整性 : 关系型数据库系统和文件系统的不同点是，关系数据库本身能保证存储数据的完整性，不需要应用程序的控制。
    而文件系统一般需要在程序段进行控制。
    数据完整性有以下三种形式：
    （a）实体完整性保证表中有一个主键。
         在InnoDB存储引擎表中，用户可以通过定义Primary Key 或 Unique Key约束来保证实体的完整性。

    （b）域完整性保证数据每列的值满足特定的条件。以下几种方式可以保证
         选择合适的数据类型确保一个数据值满足特定条件。
         外键约束
         编写触发器
         用DEFAULT约束作为强制域完整性的一个方面

     (c) 参照完整性保证两张表之间的关系。InnoDB存储引擎支持外键，因此允许用户定义外键以强制参照完整性，也可以通过编写触发器以强制执行。

(2) 约束的创建和查找
    约束的创建可以采用以下两张方式：表建立时就进行约束定义，利用ALTER TABLE命令来进行创建约束
    查看表的约束：
    select constraint_name , constraint_type from information_schema.TABLE_CONSTRAINTS
    where table_name = 'reading_book'

(3) 约束和索引的区别
    注意 当用户创建了一个唯一索引就创建了一个唯一的约束。
    但是约束和索引的概念还是不同的，约束更是一个逻辑的概念，用来保证数据的完整性
    而索引是一个数据结构，既有逻辑上的概念，在数据库中还代表物理存储的方式。

    在 MySQL中的key是同时具有constraint和index的意义 : 例如
    primary key
        有两个作用，一是约束作用（constraint），用来规范一个存储主键和唯一性，但同时也在此key上建立了一个index；
    unique key
        也有两个作用，一是约束作用（constraint），规范数据的唯一性，但同时也在这个key上建立了一个index；
    foreign key
        也有两个作用，一是约束作用（constraint），规范数据的引用完整性，但同时也在这个key上建立了一个index；

(4) 对错误数据的约束 : MYSQL数据库允许非法的或不正确的数据的插入或更新，又或者可以在数据库内部将其转化为一个合法的值
(5) Enum 和 Set约束 : MYSQL数据库不支持传统的CHECK约束，但是通过ENUM和SET类型可以解决部分这样的约束需求。
    例如：
    CREATE TABLE a(
        id int,
        sex enum('male','female');
    )
    并且 SET sql_mode = 'STRICT_TRANS_TABLES'
    通过这样的方式可以保证：只能插入'male','female'

(6) 触发器与约束
    完整性约束可以使用触发器来实现
    一个Mysql表最多可以建立6个触发器，并且Mysql只支持行级触发器

(7) 外键约束 : 外键用来保证参照完整性
    Myisam存储引擎本身并不支持外键。而InnoDB存储引擎支持完整的外键约束
    父表和子表: 会有级联关系
    当对父表操作ON DELETE 或 ON UPDATE时
    对相应子表进行操作
        CASCADE : DELETE 和 UPDATE
        SET NULL : 设置为NULL
        NO ACTION : 不操作
        RESTRICT : 不让对父表修改，抛出错误

7 视图：不关系基本的结构，只需要按照视图定义来取数据或更新数据。

  视图是一个命名的虚表，不存储数据的 。作用：它是一个抽象的模型，不需要关系基表的结构，按照视图的定义就可以获取/更新数据

  Mysql实现物化视图：本身并不支持物化视图，Mysql数据库中的视图总是虚拟的。可以通过一些机制实现物化视图
  (1) ON DEMAND 物化视图：用户只需定时把数据导入到另一个表
      定义一个表_MV表
      create table Orders_MV

      Insert into Orders_MV select product_name,sum(price),sum(amount),avg(price) from orders group by product_name

      然后每次使用时，都把表清空，重新导入数据即可。

  (2) ON COMMIT 物化视图
      必须创建触发器 ; 对表进行操作

8 分区表 : MYSQL数据库分区将一个表或索引分解为更小的单元，只支持水平分区。
对于一般的oltp应用都不用分区。分区适合olap

第五章 索引与算法

1、InnoDB存储引擎索引概述

2、数据结构与算法
(1) 二分查找法: 将记录有序化排列，在查找过程中采用跳跃式的方式查找，先以有序数列的中点位置为比较对象，如果要找的元素值小于该中点元素
则将待查序列缩小为左半部分，否则为右半部分。

3、B+树索引 : 数据结构(平衡树)

4、聚集索引
聚集索引和辅助索引的区别：B+树叶子节点存放的是否是一整行的信息
(1) 聚集索引：就是按照每张表的主键构造一棵B+树.
    表中数据按照主键顺序存放，聚集索引就是按照每张表的主键构造一个B+树。
    同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。
    由于数据页（整行记录）"只能按照一棵B+"(排序规则)进行顺序，每张表只能有一个聚簇索引。

(2) 辅助索引：B+树叶子节点中只包含索引键，不包含行记录数据，通过辅助索引来寻找数据时，会先获得聚集索引，再通过主键找到记录
    可以创建多个B+树，这些B+树都会通过指针指向聚簇索引

(3) 查看索引：
    show INDEX from reading_book
    包含一个重要字段：通过Cardinality值查看索引是否具有高选择性
    alter table t add key idx(a,c); 创建联合索引

(4) B+树索引的使用
    1、联合索引，要从最左匹配，因为构建的B+树种叶子节点的数据排序都是从最左开始的
    注意：Extra选项中可以看到Using filesort，需要一次额外的排序才能完成查询。

    2、覆盖索引： 从辅助索引中可以得到查询的记录，而不需要查询聚集索引中的记录。使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息。
    减小IO操作。(MySQL只需要通过索引就可以返回查询所需要的数据，而不必在查到索引之后进行回表操作)
    Extra看到Using index使用覆盖索引操作

    索引提示：可以显示让优化器使用哪个索引。

    例子
    create table t(
        a int,
        b int,
        key (a),
        key (b)
    )engine = innodb;

    select  * from t where a = 1 and b = 2
    Extra提示：Using intersect(b,a) 表示根据两个索引得到的结果进行求交运算
    可以强制使用一个索引： select * from force index(a) where a = 1 and b =2

全文检查：倒排索引来实现 (存储了单词与单词自身在一个或多个文档所在位置之间的映射)

哈希索引 : 哈希索引只能用来搜索等值的查询
哈希算法 :
自适应哈希索引：
    InnoDB存储引擎会监控对表上索引的查找，如果观察到建立哈希索引可以带来速度的提升，则建立哈希索引，所以称之为自适应（adaptive） 的。
    自适应哈希索引通过缓冲池的B+树构造而来，因此建立的速度很快。
    而且不需要将整个表都建哈希索引，InnoDB存储引擎会自动根据访问的频率和模式 来为某些页建立哈希索引

查询哈希索引 show engine innodb status




































