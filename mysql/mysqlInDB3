锁
    latch:
        通过命令 （show engine innodb mutex）查看
    lock:
        通过命令  show engine innodb status
    锁的粒度
        A. 表锁(Table Lock)
        对整个表加锁，影响标准的所有记录。通常用在DDL语句中，如DELETE TABLE,ALTER TABLE等。

        B. 行锁(Row Lock)
        对一行记录加锁，只影响一条记录。通常用在DML语句中，如INSERT, UPDATE, DELETE等。

一、InnoDB 存储引擎中的锁
    1、锁的类型
       共享锁S: 允许事务读一行数据
       排他锁X: 允许事务删除或更新一行数据

    2、意向锁：
       innodb支持行级上的锁与表级上的锁同时存在。
       innodb存储引擎支持意向锁,意向锁是表级别的锁。
       意向锁分为意向读锁(IS)和意向写锁(IX),没有冲突

    3、兼容性
                 IS         IX        S        X
       IS        y          y         y        n
       IX        y          y         n        y
        S        y          n         y        n
        X        n          n         n        n

    4、用于场景
    事务A锁住了表中的一行，让这一行只能读，不能写。之后，事务B申请整个表的写锁。
    如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。
    数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。

二、一致性非锁定读 ：
InnoDB存储引擎通过行“多版本控制”的方式来读取数据库中数据。如果读取的行正在执行delete或update操作,这时读取操作不会因此去等待行上锁的释放。InnoDB存储引擎会去读取行的一个快照数据,读取快照数据是不需要上锁的

可以看到，非锁定读机制极大地提高了数据库的并发性。
    在事务级别READ COMMITTED 和 REPEATABLE READ下，InnoDB存储引擎使用非锁定的一致性读。
    在这READ COMMITTED事务级别下 ： 对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据 (提交读违反了事务的隔离性)
    在REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本

    查看事务隔离级别： select @@tx_isolation

三、自增长与锁
在InnoDB存储引擎的内存结构中，对每个含有自增长的表都有一个自增长计数器。当对含有自增长的计数器的表进行插入操作时，这个计数器会被初始化
   对含有自增长的计数器的表进行操作时，这个计数器会被初始化，并执行 select max(auto_inc_col) from t for update ，这个sql语句会进行加X锁。

四、外键和锁
    外键用于引用完整性的约束检查。mysql外键会自动加上索引，如果没有创建索引
    对于外键值得插入或更新，首先需要查询父表的记录，使用select ** lock in share mode ,对父表加S锁, 但如果这时父表上已经这个加X锁，子表上的操作会被阻塞。

五、锁的算法
1、行锁的3中算法
        Record Lock    :单个行记录的锁。
        间隙锁Gap Lock :锁定一个范围，但不包含记录本身
        Next-Key Lock  :锁定一个范围，并且锁定记录本身 解决幻读问题
    在查询的索引含有唯一属性时，innoDB存储引擎会对Next-key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。
    索引非唯一时，锁住范围

    如何关闭间隙锁：将事务的隔离级别设置为READ COMMITTED

2、解决幻读 : Gap Lock
   Phantom Problem 是指在同一事务下，连续执行两次同样的sql语句可能导致不同的结果。
   比如在同一个事务A ： select * from t where a > 2 for update 两次查询
   另一个事务B : 在A事务两次 insert into t select 4 过程中

六、锁问题
    通过锁定机制可以实现事务的隔离性，使得事务可以并发地工作。锁提高了并发，但是却会带来潜在的问题。锁只会带来三种问题，如果
    可以防止这三种情况的发生，那将不会产生并发异常。
    (1) 脏读: 一个事务可以读到另外一个事务中未提交的数据，则显示违反数据库的隔离性
    (2) 不可重复读: 一个事务可以读到另外一个事务中提交的数据,第一次读和第二次读，读取的数据不一致。
    (3) 丢失更新:简单来说其就是一个事务的更新操作会被另一个事务的更新操作所覆盖。避免丢失,让事务在这种情况下的操作变成串行化

七、阻塞
八、死锁
九、InnoDB行锁的方式：不是根据每个记录来产出行锁的，而是根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式。





































