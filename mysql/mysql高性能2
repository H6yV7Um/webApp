第7章 MYSQL高级特性

一 分区表
分区表是一个独立的逻辑表,但是底层由多个物理子表组成. 从底层的文件系统来看,每个分区表都有一个使用#分隔命名的表文件

MYSQL实现分区表的方式对底层表的封装,意味着索引也是按照分区的子表定义的,而没有全局索引
MYSQL在创建表时使用PARTITION BY子句定义每个分区存放的数据.在执行查询的时候,优化器会根据分区定义过滤那些没有我们需要数据的分区
1 表非常大以至于无法全部放在内存中
2 分区表的数据更容易维护
3 分区表的数据可以分布在不同的机器上
4 可以使用分区表避免Innodb的单个索引互斥访问
使用限制
一个表最多只能有1024个分区,分区表达式必须是整数
如果分区字段中有主键或者唯一索引,那么所有主键列和唯一索引都必须包含进来
分区表无法使用外键约束

(1) 分区表的原理
存储引擎管理分区的各个底层表和管理普通表一样,分区表的索引只是在各个底层表上各自加上一个完全相同的索引.
MYSQL先确定这条记录属于那个分区,再将记录写入对应的底层分区表,无须对任何其他分区进行操作

(2) 分区表的类型
RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
 PARTITION BY RANGE (YEAR(separated)) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1996),
    PARTITION p2 VALUES LESS THAN (2001),
    PARTITION p3 VALUES LESS THAN MAXVALUE
)；

LIST分区:类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
 PARTITION BY LIST(store_id)
    PARTITION pNorth VALUES IN (3,5,6,9,17),
    PARTITION pEast VALUES IN (1,2,10,11,19,20),
    PARTITION pWest VALUES IN (4,12,13,14,18),
    PARTITION pCentral VALUES IN (7,8,15,16)
)；

HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY HASH(store_id)
PARTITIONS 4；它表示表将要被分割成分区的数量

KEY分区:类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL 服务器提供其自身的哈希函数
CREATE TABLE tk (
    col1 INT NOT NULL,
    col2 CHAR(5),
    col3 DATE
)
PARTITION BY LINEAR KEY (col1)
PARTITIONS 3;

(3) 分区表使用注意
1 : null值会使分区过滤无效
2 : 分区列和索引列不匹配,会导致查询无法进行分区过滤.
3 : 分区都必须使用相同的存储引擎
4 : 分区函数和表达式也有一些限制
5 : 在查询where,分区的列不能使用函数

二 视图 : 视图本身是一个虚拟表,不存放任何数据.比较灵活,好维护
1 视图特点:不能创建触发器,也不能使用DROP TABLE删除视图

2 可更新视图 : 因为视图是一个虚拟表，其中没有数据，所以通过视图更新时，都是转换到基本表来更新
CHECK OPTION : 表示任何通过视图更新的行,都必须符合视图本身的where条件定义.
3 处理视图的算法: 合并算法和临时表算法
4 MYSQL视图不支持物化视图,也不支持索引

三 外键约束
InnoDB是目前MYSQL中唯一支持外键的内置存储引擎
使用外键是有成本的: 每次在修改数据时都要在另一张表执行一次查找操作
但如果想确保两个相关表始终有一致的数据,那么使用外键比在应用程序中检查一致性的性能要高得多.

四 MYSQL内部存储代码
MYSQL允许通过触发器,存储过程,函数的形式来存储代码.从MYSQL5.1开始,还可以在定时任务中存放代码,这个定时任务也被称为"事件".

存储过程和存储函数都可以接受参数然后返回值,但是触发器和事件却不可以
存储代码的优点: 在服务器内部执行,代码重用; 缺点: 存储代码效率要稍微查,难实现太复杂的逻辑

(1) 存储过程和函数
DELIMITER
    CREATE PROCEDURE proc1(OUT s int)
        BEGIN
            SELECT COUNT(*) INTO s FROM user;
        END
DELIMITER ;

(2) 触发器 : 触发器可以让你在执行INSERT,UPDATE或DELETE的时候,执行一些特定的操作
注意
对每个表的每一个事件,最多只能定义一个触发器.MYSQL只支持"基于行的触发"也就是说,触发器始终是针对一条记录的
触发器可能导致死锁和锁等待.
触发器并不能一定保证更新的原子性.如MyISAM存储引擎
INNODB表上的触发器是在同一个事务中完成的,所以他们执行的操作是原子的.
CREATE TRIGGER t_afterinsert_on_tab1
AFTER INSERT ON tab1
FOR EACH ROW
BEGIN
     insert into tab2(tab2_id) values(new.tab1_id);
END;

(3) 事件: 指定Mysql在某个时候执行一段SQL代码,或者每隔一个时间间隔执行一段SQL代码.可以把复杂的SQL都封装到一个存储过程中, 这样事件在执行的时候只需要做一个简单的CALL调用
CREATE EVENT test ON SCHEDULE EVERY 1DAY
STARTS '2012-08-22 00:00:00'
ENDS '2012-08-22 00:00:00'+INTERVAL40 DAY
ON COMPLETION PRESERVE DO
CALL test_add();// 可以是调存储过程,也是执行MYSQL语句

五 游标
MYSQL提供只读,单向的游标,而且只能在存储过程或者更底层的客户端使用.
游标中指向的对象都是存储在临时表中而不是实际查询到的数据,所以mysql游标总是只读的.它可以每行得指向查询结果,然后让程序做进一步处理

在存储过程里面用到游标，逐条更新数据
CREATE PROCEDURE CURSOR()
BEGIN
 DECLARE  no_more_record INT DEFAULT 0;
 DECLARE  pID BIGINT(20);
 DECLARE  pValue DECIMAL(15,5);
 DECLARE  cur_record CURSOR FOR   SELECT colA, colB from tableABC;  /*首先这里对游标进行定义*/
 DECLARE  CONTINUE HANDLER FOR NOT FOUND  SET  no_more_record = 1; /*这个是个条件处理,针对NOT FOUND的条件,当没有记录时赋值为1*/

 OPEN   cur_record; /*接着使用OPEN打开游标*/
 FETCH  cur_record INTO pID, pValue; /*把第一行数据写入变量中,游标也随之指向了记录的第一行*/

 WHILE   no_more_record != 1 DO INSERT  INTO testTable(ID, Value) VALUES  (pID, pValue);
 FETCH   cur_record INTO pID, pValue;

 END WHILE;
 CLOSE  cur_record;  /*用完后记得用CLOSE把资源释放掉*/
END

六 绑定变量
1 服务器只需要解析一次SQL语句
2 不需要将整个查询语句发送到服务器端,只需要传参数
3 避免SQL注入和攻击

七 用户自定义函数

八 字符集和校对 : 字符集是一种从二进制到某类字符符号的映射
MySQL使用字符集
创建数据库的时候,将根据服务器上的character_set_server设置来设定该数据库的默认字符集
创建表的时候,将根据数据库的字符集设置指定这个表的字符集设置
创建列,根据设置列的字符集设置

服务器和客户端会有字符集转换过程: character_set_client -> character_set_connection -> character_set_result

MYSQL比较两个字符串的大小 : 必须转为同一个字符集再进行比较

选择字符集和校对规则
查看字符集 : show charset
查看校验规则 : SHOW COLLATION