第一部分
基本概念
对象的状态是指存储在状态变量中的数据,对象的状态可能包括其他依赖对象的域。
例如HashMap的状态不仅存储在HashMap对象本身，还存储在Map.Entry对象中

要使得对象是线程安全的，需要采用同步机制来协同访问对象的可变的状态变量
java中的主要同步机制是关键字synchronized，他提供了一种独占的加锁方式，而同步还包括volatile类型变量，显示锁以及原子变量

遇到同步问题：如果当多个线程访问同一个可变的状态变量时，没有使用合适的同步，那么程序就会出现错误
1:不在线程之间共享该状态变量 (无状态对象是线程安全的)
2:将状态变量修改为不可变的变量
3:在访问状态变量时使用同步

第2章 (线程安全性)

一、什么是线程安全性
当多个线程访问某个类时，这个类始终表现出正确的行为，这个类是线程安全的，在线程安全类中，封装了必要的同步机制

二、原子性
由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况: 竞态条件
避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量

1: 线程安全类AtomicLong
incrementAndGet() 方法 : 首先会根据get()获取AtomicLong对应的long值。该值是volatile类型的变量
使用AtomicLong的状态变量，对于多线程是安全的

三、加锁机制 synchronized
同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块
1、synchronized来修饰的非static方法，锁就是方法调用所在的对象
2、静态方法，锁Class对象

3、内置锁重入: 某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功
实现原理：当线程请求一个未被持有的锁时，jvm将记下锁的持有者，并且将获取计数值设置为1
如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块，计数器会相应地递减。
当计数值为0,这个锁将被释放.

如果没有不可重入
public class Widget{
    public synchronized void doSomething(){

    }
}
public class LoggingWidget extends Widget{
    public synchronized void doSomething(){
        super.doSomething();
    }
}

4、用锁来保护状态

5、性能
通过缩小同步代码块的作用范围，可以提高一些并发的性能

第3章（对象的共享）

1、可见性 : 无法保证执行读操作的线程能适时地看到其他线程写入的值，所以必须使用同步机制
(1)下面代码：不可见的例子
public class NoVisibility {
    private static boolean ready;
    private static int number;

    private static class ReaderThread extends Thread{
        public void run(){
            while (!ready)
                Thread.yield();
            System.out.println(number);
        }
    }
    public static void main(String[] args){
        new ReaderThread().start();
        number = 42;
        ready = true;
    }
}
重排序 ： 当主线程首先写入number，在没有同步的情况下写入ready，那么读线程看到的顺序可能与写入的顺序相反

(2)非原子的64位操作
1 当线程在没有同步的情况下读取变量时，可能会得到一个失效值
2 非volatile类型的64位数值，long和double变量，jvm允许将64位的读操作和写操作分解为两个32位的操作，当读取一个
非volatile类型的long变量时，如果对该变量的读操作和写操作再不同的线程中执行。
所以多线程中使用long和double时，要使用volatile来声明

(3)加锁与可见性

(4) Volatile变量 用来确保将变量的更新操作通知到其他线程
使用Volatile变量不会使执行线程阻塞，通常用做操作完成，发生中断或者状态的标志
使用条件（由于不满足原子性，所以受限制）
1:对变量的写入操作不依赖变量的当前值: boolean
2:只有一个线程对共享volatile变量执行写入操作，那么就可以安全地在这些共享的volatile变量上执行

2 发布与逸出
对象不正确的发布(逸出)
1、发布对象的最简单方法:
是将对象的引用保存到一个公有的静态变量中;
从非私有方法中返回一个引用，同样会发布返回的对象

3、线程封闭 : 避免使用同步的方式就是不共享数据
Java类库线程封闭技术，局部变量和ThreadLocal类
栈封闭:局部变量
(1) 基本类型的局部变量，不需要任何操作
(2) 对象引用的栈封闭，如果发布了对象的引用，封闭性将被破坏

4、ThreadLocal类 : 防止对可变的单实例变量或全局变量进行共享
使用该变量的线程都存有一份独立的副本，因此get总是返回由当前执行线程再调用set时设置的最新值
使用场景:将JDBC的连接保存到ThreadLocal对象，每个线程都会拥有自己的连接,确保线程安全

5、不变性 final: 不可变对象一定是线程安全的

6、安全发布
不安全的发布:在没有同步的情况下发布对象
要安全发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见,下面是安全发布的方式
(1) 在静态初始化函数中初始化一个对象的引用 : 有jvm在类的初始化阶段执行，由于jvm内部存在同步机制
(2) 将对象的引用保存到volatile类型的域或者AtomicReferance对象中
(3) 将对象的引用保存到某个正确构造对象的final类型域中
(4) 将对象的引用保存到一个由锁保护的域中

在线程安全容器内部的同步意味着，在将对象放入到某个容器，vector 或 synchronizedList
如果线程A将对象放入一个线程安全的容器，随后线程B读取这个对象，
那么可以确保看到A设置的X状态,即便在这段读/写 X的应用程序代码中没有包含显式的同步
java线程安全库的容器类
通过将一个键或者值放入Hashtable、synchronizedMap或者ConcurrentMap
通过把一个元素放入 Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList
通过把一个元素放入 BlockingQueue或者ConcurrentLinkedQueue

(5) 事实不可变对象 : 如果对象从技术上是可变的，但其状态在发布后不会再改变，称为事实不可变对象
public Map<String,Date> lastLogin = Collections.synchronizedMap(new HashMap<String,Date>());
如果Date对象值放入Map就改变，那么synchronizedMap同步机制就足以使Date值被安全地发布

(6) 三种对象正确的发布
a: 不可变对象可以通过任意机制来发布
b: 事实不可变对象必须通过安全方式来发布
c: 可变对象 必须是线程安全或者有某个锁保存起来








































