第一部分 线程安全性
基本概念
对象的状态是指存储在状态变量中的数据,对象的状态可能包括其他依赖对象的域。
例如HashMap的状态不仅存储在HashMap对象本身，还存储在Map.Entry对象中

要使得对象是线程安全的，需要采用同步机制来协同访问对象的可变的状态变量
java中的主要同步机制是关键字synchronized，他提供了一种独占的加锁方式，而同步还包括volatile类型变量，显示锁以及原子变量

遇到同步问题：如果当多个线程访问同一个可变的状态变量时，没有使用合适的同步，那么程序就会出现错误
1:不在线程之间共享该状态变量 (无状态对象是线程安全的)
2:将状态变量修改为不可变的变量
3:在访问状态变量时使用同步

一、什么是线程安全性
当多个线程访问某个类时，这个类始终表现出正确的行为，这个类是线程安全的，在线程安全类中，封装了必要的同步机制

二、原子性
由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况: 竞态条件
避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量

1: 线程安全类AtomicLong
incrementAndGet() 方法 : 首先会根据get()获取AtomicLong对应的long值。该值是volatile类型的变量
使用AtomicLong的状态变量，对于多线程是安全的

三、加锁机制 synchronized
同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块
1、synchronized来修饰的非static方法，锁就是方法调用所在的对象
2、静态方法，锁Class对象

3、内置锁重入: 某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功
实现原理：当线程请求一个未被持有的锁时，jvm将记下锁的持有者，并且将获取计数值设置为1
如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块，计数器会相应地递减。
当计数值为0,这个锁将被释放.

如果没有不可重入
public class Widget{
    public synchronized void doSomething(){
    
    }
}
public class LoggingWidget extends Widget{
    public synchronized void doSomething(){
        super.doSomething();
    }
}












