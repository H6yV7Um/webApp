第一部分
基本概念
对象的状态是指存储在状态变量中的数据,对象的状态可能包括其他依赖对象的域。
例如HashMap的状态不仅存储在HashMap对象本身，还存储在Map.Entry对象中

要使得对象是线程安全的，需要采用同步机制来协同访问对象的可变的状态变量
java中的主要同步机制是关键字synchronized，他提供了一种独占的加锁方式，而同步还包括volatile类型变量，显示锁以及原子变量

遇到同步问题：如果当多个线程访问同一个可变的状态变量时，没有使用合适的同步，那么程序就会出现错误
1:不在线程之间共享该状态变量 (无状态对象是线程安全的)
2:将状态变量修改为不可变的变量
3:在访问状态变量时使用同步

第2章 (线程安全性)

一、什么是线程安全性
当多个线程访问某个类时，这个类始终表现出正确的行为，这个类是线程安全的，在线程安全类中，封装了必要的同步机制

二、原子性
由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况: 竞态条件
避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量

1: 线程安全类AtomicLong
incrementAndGet() 方法 : 首先会根据get()获取AtomicLong对应的long值。该值是volatile类型的变量
使用AtomicLong的状态变量，对于多线程是安全的

三、加锁机制 synchronized
同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块
1、synchronized来修饰的非static方法，锁就是方法调用所在的对象
2、静态方法，锁Class对象

3、内置锁重入: 某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功
实现原理：当线程请求一个未被持有的锁时，jvm将记下锁的持有者，并且将获取计数值设置为1
如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块，计数器会相应地递减。
当计数值为0,这个锁将被释放.

如果没有不可重入
public class Widget{
    public synchronized void doSomething(){

    }
}
public class LoggingWidget extends Widget{
    public synchronized void doSomething(){
        super.doSomething();
    }
}

4、用锁来保护状态

5、性能
通过缩小同步代码块的作用范围，可以提高一些并发的性能

第3章（对象的共享）

1、可见性 : 无法保证执行读操作的线程能适时地看到其他线程写入的值，所以必须使用同步机制
(1)下面代码：不可见的例子
public class NoVisibility {
    private static boolean ready;
    private static int number;

    private static class ReaderThread extends Thread{
        public void run(){
            while (!ready)
                Thread.yield();
            System.out.println(number);
        }
    }
    public static void main(String[] args){
        new ReaderThread().start();
        number = 42;
        ready = true;
    }
}
重排序 ： 当主线程首先写入number，在没有同步的情况下写入ready，那么读线程看到的顺序可能与写入的顺序相反

(2)非原子的64位操作
1 当线程在没有同步的情况下读取变量时，可能会得到一个失效值
2 非volatile类型的64位数值，long和double变量，jvm允许将64位的读操作和写操作分解为两个32位的操作，当读取一个
非volatile类型的long变量时，如果对该变量的读操作和写操作再不同的线程中执行。
所以多线程中使用long和double时，要使用volatile来声明


















