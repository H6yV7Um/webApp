一、java虚拟机的基本结构
1、局部变量表
   局部变量表对垃圾回收器的影响
public void localvarGc1(){
    byte[] a = new byte[6*1024*1024];
    system.gc(); 无法回收
}

public void localvarGC2(){
    byte[] a = new byte[6*1024*1024];
    a = null;
    system.gc();可以回收
}

public void localvarGC3(){
    {
        byte[] a = new byte[6*1024*1024];
    }
    system.gc();a失效，但局部变量表还有，不能回收
}

public void localvarGC4(){
    {
        byte[] a = new byte[6*1024*1024];
    }
    int c = 10;
    System.gc();a失效，c将a在局部变量表中的内容替代，不能回收
}

public void localvarGC5(){
    localvarGC1();
    System.gc(); 方法完成后，局部变量表没有，可以回收
}

2、操作数栈
   操作数栈也是栈帧中重要的内容之一，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。

3、方法区
   通过CGLIB生产大量的动态类，会保存在方法区
   jdk1.8 永久区已经被移除，取而代之的是元数据区。是一块堆外的直接内存。

二、java虚拟机参数
（1）打印和跟踪参数
    1、-XX:+PrintGC 只要有GC就会打印
    2、-XX:+PrintGCDetail 可以打印详细的信息

    3、类加载和卸载跟踪 -verbose:class
       -XX:+TraceClassLoading 或者 -XX:+TraceClassUnLoading
    4、-XX:+PrintVMOption: 打印虚拟机接受到的命令行显示参数

(2) 学习堆的配置参数
     1：初始堆和最大堆
        初始堆大小设置：-Xms
        最大堆空间设置：-Xmx

     2: 新生代配置
        -Xmn 一般设置为整个推空间1/3到1/4左右
        -XX:SurvivorRatio : 用来设置新生代中eden空间和from/to空间比例关系
        基本策略是：尽可能将对象预留在新生代，减少老年代GC的次数
        可以使用-XX:NewRatio 来设置新生代和老年代的比例

     3: 堆溢出处理
        堆信息：-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/a.dump
        线程转存：D:/tools/jdk*/bin/jstack -F %1 > D:/a.txt

(3) 非堆内存的参数配置
        1、方法区配置:
            使用-XX:PermSize设置初始值方法区的大小，-XX:MaxPermSize最大方法区大小
            JDK1.8 虽然方法区彻底删除，但可以使用-XX:MaxMetaspaceSize指定永久区的最大可用值

        2、栈配置: erfe
            栈是每个线程私有的内存空间
            可以使用-Xss参数指定线程的栈大小

        3、直接内存配置:一般来说，直接内存的访问速度会快于堆内存。但堆内存申请的速度快于直接内存。
            NIO使用
            最大可用直接内存可以使用参数-XX:MaxDirectMemorySize设置。

三、垃圾回收算法
    1、标记清除
    2、复制算法
    3、标记压缩
    4、分代算法： 新生代用复制算法，老年代标记清除和标记压缩
    5、分区算法：将整个堆空间划分为连续的不同小区间。每次合理回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。

(2) 判断可触及性
    只有当对象不可触及时才可以被回收
    不可触及的对象： 对象的finalize()函数被调用，并且没有复活，那么就会进入不可触及状态，不可触及的对象不可能被复活。

    引用类型：
        强引用可以直接访问目标对象,但强引用不会被回收，可能导致内存泄露。
        软引用: 当堆空间不足时，就会被释放。软引用对象不会内存溢出。
        弱引用: 只要发生GC，就会被回收
        虚引用: 随时都可能被回收









