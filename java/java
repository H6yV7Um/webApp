一
    1、mysql innodb存储引擎文件结构
        (1)表空间 :
        (2)段:
        (3)区:每64个连续的页组成区，因此区大小正好为1M
        (4)页:页是InnoDB磁盘管理的最小单位，固定大小为16K，不可以更改
        (5)行:InnoDB表中数据按行存储
    2、索引树是如何维护
        B树索引
        哈希索引
    3、数据库自增主键可能问题
        使用自增主键对数据库做分库分表，可能出现一些诸如主键重复等的问题，或者在数据库导入的时候，可能会因为主键出现一些问题
    4、Redis的并发竞争问题如何解决
        1.客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。
        2.服务器角度，利用setnx实现锁。
    5、Redis事务CAS操作
        使用 watch命令
    6、动态代理几种方法
       jdk动态代理和cglib动态代理
       jdk动态代理是由Java内部的反射机制来实现的;jdk动态代理的应用前提，必须是目标类基于统一的接口
       cglib动态代理底层则是借助asm来实现的(ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为)
       它的运行速度要远远快于JDK的Proxy动态代理
    7、Spring AOP与IOC的实现
       AOP的源码中用到了两种动态代理来实现拦截切入功能：jdk动态代理和cglib动态代理

    8、为什么GClib方式可以对接口实现代理（同6）

    9、RMI与代理模式
    10、Dubbo
    11、JVM垃圾回收执机制，何时触发MinorGC
        当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了

    12、新生代和老年代内存回收策略
        Minor GC 的情况就相当清楚了——每次 Minor GC 会清理年轻代的内存。
        Major GC 是清理老年代。
        Full GC 是清理整个堆空间—包括年轻代和老年代。

        stop-the-world: 在垃圾回收器，标记阶段，停止所有应用程序的线程

    13、Eden和Survivor比例
        1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1
        因为是使用复制算法，不会产生磁盘碎片

    14、Synchonized和Lock

二
    1、JVM内存分代
       1.程序计数器 : 它保存的是程序当前执行的指令的地址
       2.Java栈 : Java栈是Java方法执行的内存模型: 包含栈帧(局部变量表，操作数栈，运行时常量池的引用，返回的返回地址，附件信息)
       3.本地方法栈
       4.堆 : Java中的堆是用来存储对象本身的以及数组
       5.方法区 : 存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。

    2、java8的内存分代的改进
        Metaspace 与 PermGen space
        但永久代仍存在于JDK1.7中，并没完全移除，
            譬如符号引用(Symbols)转移到了native heap；
            字面量(interned strings)转移到了java heap；
            类的静态变量(class statics)转移到了java heap。

        JDK1.8 Metaspace元空间并不在虚拟机中，而是使用本地内存

    3、深入分析ClassLoader，双亲委派机制
       类加载器负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例

       某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载

       理解
          java虚拟机中的class其实都是通过classloader来装载的
          只有当你使用该class的时候才会去装载，一个classloader只会装载同一个class一次。双亲委派机制能在很大程度上防止内存中出现多个相同的字节码文件
          不同的类加载器的实例所加载的字节码文件，其通过反射获取的对象不是相同类型（相互赋值会抛出类型强转异常）。即：判断两个类是否为同一对象的标准里面有一条是类加载器必须为相同。
          在加载类的时候默认会使用当前类的ClassLoader进行加载（类A中引用了类B，JVM会用类A的类加载器加载类B）。
          在线程中加载一个类的时候：当前线程的类加载器可以通过Thread类的getContextClassLoader()获得，也可以通过setContextClassLoader()自己设置类加载器

          按照双亲委派机制加载类，每当需要加载一个新的类时，当前的类加载器会先委托其父加载器，查询有没有加载该类。
          如果父类加载器已近加载该类，那么直接返回加载的class对象，如果没有那么继续向上寻找父类加载器，如果在祖宗类加载器Bootstrap都没有加载该类，那么需要当前的类加载器自己加载，
          如果当前的类加载器也不能加载则会跑出ClassNotFoundException异常

          Bootstrap ClassLoader : Bootstrap类加载器不是Java写的，开发者无法直接获取到启动类加载器的引用
          Extension : 开发者可以直接使用标准扩展类加载器

    4、JVM的编译优化 : http://blog.csdn.net/kobejayandy/article/details/39620221
       Java语言的“编译期”是一段不确定的过程，因为它可能指的是前端编译器把java文件转变成class字节码文件的过程，也可能指的是虚拟机后端运行期间编译器（JIT）把字节码转变成机器码的过程。
       编译期优化指的是javac编译器将java文件转化为字节码的过程，而运行期间优化指的是JIT编译器所做的优化

       (1) javac编译器的编译过程大致可分为步骤：
           经过语法分析，词法分析，语法树 检查，验证，字节码生成

       (2) 运行时优化
           java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块运行特别频繁，就会把这些代码认定为“热点代码”，为了提高热点代码的执行效率，
           在运行时，虚拟机就会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器或JIT编译器


    5、java内存模型理解

    6、指令重排序，内存栅栏

    7、HashMap的并发问题

    8、LinkedHashMap的应用

    9、多路并规的时间复杂度

    10、java nio的使用

    11、倒排索引

    12、分词技术

三
    1、分布式事务的理解

    2、设计模式

    3、大量用户数据如何在内存中排序和去重

    4、缓存机器增删如何对系统影响最小，一致性哈希的实现

    5、Redis持久化的几种方式

    6、Redis的缓存失效策略

    7、TOP k的问题

