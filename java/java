一
    1、mysql innodb存储引擎文件结构
        (1)表空间 :
        (2)段:
        (3)区:每64个连续的页组成区，因此区大小正好为1M
        (4)页:页是InnoDB磁盘管理的最小单位，固定大小为16K，不可以更改
        (5)行:InnoDB表中数据按行存储
    2、索引树是如何维护
        B树索引
        哈希索引
    3、数据库自增主键可能问题
        使用自增主键对数据库做分库分表，可能出现一些诸如主键重复等的问题，或者在数据库导入的时候，可能会因为主键出现一些问题
    4、Redis的并发竞争问题如何解决
        1.客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。
        2.服务器角度，利用setnx实现锁。
    5、Redis事务CAS操作
        使用 watch命令
    6、动态代理几种方法
       jdk动态代理和cglib动态代理
       jdk动态代理是由Java内部的反射机制来实现的;jdk动态代理的应用前提，必须是目标类基于统一的接口
       cglib动态代理底层则是借助asm来实现的(ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为)
       它的运行速度要远远快于JDK的Proxy动态代理
    7、Spring AOP与IOC的实现
       AOP的源码中用到了两种动态代理来实现拦截切入功能：jdk动态代理和cglib动态代理

    8、为什么GClib方式可以对接口实现代理（同6）

    9、RMI与代理模式
    10、Dubbo
    11、JVM垃圾回收执机制，何时触发MinorGC
        当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了

    12、新生代和老年代内存回收策略
        Minor GC 的情况就相当清楚了——每次 Minor GC 会清理年轻代的内存。
        Full GC 是清理整个堆空间—包括年轻代和老年代。

        Minor GC ，Full GC 触发条件
        Minor GC触发条件：当Eden区满时，触发Minor GC。
        Full GC触发条件：
        （1）调用System.gc时，系统建议执行Full GC，但是不必然执行
        （2）老年代空间不足
        （3）方法去空间不足
        （4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存
        （5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

        stop-the-world: 在垃圾回收器GC时候，标记阶段，停止所有应用程序的线程

    13、Eden和Survivor比例
        1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1
        因为是使用复制算法，不会产生磁盘碎片

    14、Synchonized和Lock

二
    1、JVM内存分代
       1.程序计数器 : 它保存的是程序当前执行的指令的地址
       2.Java栈 : Java栈是Java方法执行的内存模型: 包含栈帧(局部变量表，操作数栈，运行时常量池的引用，返回的返回地址，附件信息)
       3.本地方法栈
       4.堆 : Java中的堆是用来存储对象本身的以及数组
       5.方法区 : 存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。

    2、java8的内存分代的改进
        Metaspace 与 PermGen space
        但永久代仍存在于JDK1.7中，并没完全移除，
            譬如符号引用(Symbols)转移到了native heap；
            字面量(interned strings)转移到了java heap；
            类的静态变量(class statics)转移到了java heap。

        JDK1.8 Metaspace元空间并不在虚拟机中，而是使用本地内存

    3、深入分析ClassLoader，双亲委派机制
       类加载器负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例

       某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载

       理解
          java虚拟机中的class其实都是通过classloader来装载的
          只有当你使用该class的时候才会去装载，一个classloader只会装载同一个class一次。双亲委派机制能在很大程度上防止内存中出现多个相同的字节码文件
          不同的类加载器的实例所加载的字节码文件，其通过反射获取的对象不是相同类型（相互赋值会抛出类型强转异常）。即：判断两个类是否为同一对象的标准里面有一条是类加载器必须为相同。
          在加载类的时候默认会使用当前类的ClassLoader进行加载（类A中引用了类B，JVM会用类A的类加载器加载类B）。
          在线程中加载一个类的时候：当前线程的类加载器可以通过Thread类的getContextClassLoader()获得，也可以通过setContextClassLoader()自己设置类加载器

          按照双亲委派机制加载类，每当需要加载一个新的类时，当前的类加载器会先委托其父加载器，查询有没有加载该类。
          如果父类加载器已近加载该类，那么直接返回加载的class对象，如果没有那么继续向上寻找父类加载器，如果在祖宗类加载器Bootstrap都没有加载该类，那么需要当前的类加载器自己加载，
          如果当前的类加载器也不能加载则会跑出ClassNotFoundException异常

          Bootstrap ClassLoader : Bootstrap类加载器不是Java写的，开发者无法直接获取到启动类加载器的引用
          Extension : 开发者可以直接使用标准扩展类加载器

    4、JVM的编译优化 : http://blog.csdn.net/kobejayandy/article/details/39620221
       Java语言的“编译期”是一段不确定的过程，因为它可能指的是前端编译器把java文件转变成class字节码文件的过程，也可能指的是虚拟机后端运行期间编译器（JIT）把字节码转变成机器码的过程。
       编译期优化指的是javac编译器将java文件转化为字节码的过程，而运行期间优化指的是JIT编译器所做的优化

       (1) javac编译器的编译过程大致可分为步骤：
           经过语法分析，词法分析，语法树 检查，验证，字节码生成

       (2) 运行时优化
           java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块运行特别频繁，就会把这些代码认定为“热点代码”，为了提高热点代码的执行效率，
           在运行时，虚拟机就会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器或JIT编译器

    5、java内存模型理解
       Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存（可以与前面将的处理器的高速缓存类比），
       线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量
       不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成

    6、指令重排序，内存栅栏
       重排序是指“编译器和处理器”为了提高性能，而在程序执行时会对程序进行的重排序。
       通过内存屏障可以禁止特定类型处理器的重排序，从而让程序按我们预想的流程去执行
       JMM内存屏障指令 : LoadLoad屏障 \ StoreStore屏障 \ LoadStore屏障 \ StoreLoad屏障

    7、HashMap的并发问题
       HashMap是非线程安全的，多个线程put的时候造成了某个key值Entry key List的死循环

    8、LinkedHashMap的应用
       双向循环链表，因此它保留了节点插入的顺序，可以使节点的输出顺序与输入顺序相同

    9、多路并规的时间复杂度
       O(nlogn)

    10、java nio的使用
        Java NIO和BIO之间的主要差别:
        IO                NIO
        面向流            面向缓冲
        Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。
        阻塞IO            非阻塞IO
        Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了

        Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道
        无                选择器
        一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道

    11、倒排索引 : 倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表

    12、分词技术

三
    1、分布式事务的理解
      分布式事务指的是允许多个独立的事务资源参与到一个全局的事务中。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚。

    2、设计模式

    3、大量用户数据如何在内存中排序和去重

    4、缓存机器增删如何对系统影响最小，一致性哈希的实现

    5、Redis持久化的几种方式

    6、Redis的缓存失效策略

    7、TOP k的问题

