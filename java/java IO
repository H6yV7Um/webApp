1、通信模式
一、BIO : 同步阻塞,当客户端并发访问量增加后,对系统的消耗特别大

    服务端提供IP和监听端口，客户端通过连接操作想服务端监听的地址发起连接请求，通过三次握手连接，如果连接成功建立，双方就可以通过套接字进行通信。
    传统的同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信。
    (1) 一个客户端对应一个线程
        简单的描述一下BIO的服务端通信模型：
        通常由一个独立的Acceptor线程负责监听客户端的连接，它接受到客户端连接请求后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回返回应答给客户端，线程销毁，属于一请求一应答的通信模式。

   （2）伪异步I/O编程
        使用线程池来管理这些线程（需要了解更多请参考前面提供的文章），实现1个或多个线程处理N个客户端的模型。并本身还是同步阻塞的。

二、NIO: 异步阻塞IO

    NIO提供了与传统BIO模型中的Socket和ServerSocket相对应的SocketChannel和ServerSocketChannel两种不同的套接字通道实现。新增的着两种通道都支持阻塞和非阻塞两种模式。

    NIO基础知识
        1、缓冲区 Buffer:  在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，也是写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作.
        2、通道 Channel： 我们对数据的读取和写入要通过Channel。通道不同于流的地方就是通道是双向的，可以用于读、写和同时读写操作。

        3、多路复用器 Selector ：是Java NIO编程的基础
            Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作
            一个多路复用器selector可以同时轮询多个channel，由于jdk使用了epoll()替代传统的select实现，所以它并没有最大连接句柄的限制
            这也就意味着需要一个线程负责selector的轮询，就可以接入多个客户端。

3、AIO：异步阻塞IO
    NIO 2.0引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。
    异步的套接字通道时真正的异步非阻塞I/O，对应于UNIX网络编程中的事件驱动I/O（AIO）。
    他不需要过多的Selector对注册的通道进行轮询即可实现异步读写，从而简化了NIO的编程模型
