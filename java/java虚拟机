第一部分：自动内存管理机制

第2章 java内存区域与内存溢出异常
一、运行时数据区域
(1) 程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。
字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
由于java虚拟机的多线程是通过线程轮流切换并分配处理执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令
因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响。所有线程私有的内存
注意：
如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址
如果正在执行的是Native方法，这个计数器值为空。
是唯一一个没有OutOfMemoryError的区域

(2) java虚拟机栈
1、java虚拟机栈也是线程私有的。
虚拟机栈描述的是java方法执行的内存模型：
每个方法在执行的同时都会创建一个栈帧用于存放局部变量表，操作数栈，动态链接，方法出口的信息
局部变量表存放了编译期可知的各种基本数据类型和对象引用

其中64位长度的long和double类型的数据会占用2个局部变量空间
其余的数据类型只占用1个。
局部变量表所需的内存空间在编译期间完成分配,运行期间不会改变局部变量表的大小

2、规定了两种异常: 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常;
如果虚拟机栈可以动态扩展，如果扩展无法申请到足够的内存，就会抛出OutOfMemoryError异常

(3) 本地方法栈 : 虚拟机使用到的Native方法服务。

(4) Java堆: 线程共享,内存最大
此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存
Java堆是垃圾收集器的主要区域，因此很多时候也被做"GC堆"
由于现在垃圾收集器采用分代收集算法，所以java堆中还可以细分为：新生代和老年代

(5) 方法区与java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据

(6) 运行时常量池 ： 是方法区的一部分 Class文件中除了有类的版本、字段、方法、接口等信息。
还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。

(7) 直接内存： 并不是虚拟机运行时数据区的一部分
Channel和Buffer，它可以使用Native函数库直接分配的堆外内存，然后通过一个存储在java堆中的DirectByBuffer对象作为这块内存的引用进行操作
避免了再java堆和Native堆中来回复制数据

二、HotSpot虚拟机对象探秘
(1) 对象创建
第一步：虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否在常量池中定位一个类的符号引用，并且检查这个符号引用代表的类是否被加载过
如果没有，先执行相应的类加载过程
第二步：类加载通过后，接下来虚拟机将为新生对象分配内存。对象所需内存大小在类加载完成后便可以确定。
1、java堆内存是规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，每次分配内存是把指针向空闲那边移动，这种分配的方式称为指针碰撞
2、不规整，已使用的内存和空闲的内存相互交错，虚拟机必须维护一个列表，记录那些内存块是可用的，在分配的时候从列表找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配的方式称"空闲列表"
java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
因此，在使用Serial、 ParNew等带Compact过程的收集器时，系统采用的分配算法是指针
碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表
分配内存并发问题：采用两种方式
1、对分配内存空间的动作进行同步处理
2、把内存分配的任务按照线程划分在不同的空间之中进行
第三步：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值
虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、 如何才能找到类的元数据信息、 对象的哈希码、 对象的GC分代年龄等信息

(2)对象的内存布局
对象在内存中存储的布局可以分为：对象头，实例数据和对齐填充
用于存储对象自身的运行时数据：
如哈希码，GC分代年龄，锁状态标示，线程持有的锁，偏向线程ID，偏向时间戳
用于存储类型指针：对象指向它的类元数据的指针
用于对齐填充的占位符

(3)对象的访问定位
目前主流的访问方式有使用句柄和直接指针两种

(4)OutOfMemoryError异常
(1) Java堆溢出: Java堆用于存储对象实例，只要不断地创建对象，并且保证GC  ROOTs到对象之间有可达路径来避免垃圾回收机制清除这些对象。
“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。
虚拟机的堆参数（-Xmx与-Xms）

(2) 虚拟机栈和本地方法栈溢出
栈容量只由-Xss参数
1、如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常
在多线程开发时注意：
操作系统分配给每个进程的内存是有限制的，譬如32位的Windows限制为2GB。 虚拟机提供了参数来控制Java堆和方法区的这两部分内存的最大值。
剩余的内存为2GB（操作系统限制）减去Xmx（最大堆容量），再减去MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略掉。
如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈“瓜分”了。
每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。

2、如果虚拟机在扩展是无法申请到足够的内存空间，则抛出OutOfMemberError异常

3、方法区和运行时常量池溢出
方法区异常：PermGen space
通过-XX：PermSize和-XX：MaxPermSize限制方法区大小
方法区用于存放Class的相关信息，如类名、 访问修饰符、 常量池、 字段描述、 方法描述等
当前的很多主流框架，如Spring、 Hibernate，在对类进行增强时，都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存

4、本机直接内存溢出
通过-XX：MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样
