第一部分：自动内存管理机制

第2章 java内存区域与内存溢出异常
一、运行时数据区域
(1) 程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。
字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
由于java虚拟机的多线程是通过线程轮流切换并分配处理执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令
因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响。所有线程私有的内存
注意：
如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址
如果正在执行的是Native方法，这个计数器值为空。
是唯一一个没有OutOfMemoryError的区域

(2) java虚拟机栈
1、java虚拟机栈也是线程私有的。
虚拟机栈描述的是java方法执行的内存模型：
每个方法在执行的同时都会创建一个栈帧用于存放局部变量表，操作数栈，动态链接，方法出口的信息
局部变量表存放了编译期可知的各种基本数据类型和对象引用

其中64位长度的long和double类型的数据会占用2个局部变量空间
其余的数据类型只占用1个。
局部变量表所需的内存空间在编译期间完成分配,运行期间不会改变局部变量表的大小

2、规定了两种异常: 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常;
如果虚拟机栈可以动态扩展，如果扩展无法申请到足够的内存，就会抛出OutOfMemoryError异常

(3) 本地方法栈 : 虚拟机使用到的Native方法服务。

(4) Java堆: 线程共享,内存最大
此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存
Java堆是垃圾收集器的主要区域，因此很多时候也被做"GC堆"
由于现在垃圾收集器采用分代收集算法，所以java堆中还可以细分为：新生代和老年代

(5) 方法区与java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据

(6) 运行时常量池 ： 是方法区的一部分 Class文件中除了有类的版本、字段、方法、接口等信息。
还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。

(7) 直接内存： 并不是虚拟机运行时数据区的一部分
Channel和Buffer，它可以使用Native函数库直接分配的堆外内存，然后通过一个存储在java堆中的DirectByBuffer对象作为这块内存的引用进行操作
避免了再java堆和Native堆中来回复制数据

二、HotSpot虚拟机对象探秘
(1) 对象创建
第一步：虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否在常量池中定位一个类的符号引用，并且检查这个符号引用代表的类是否被加载过
如果没有，先执行相应的类加载过程
第二步：类加载通过后，接下来虚拟机将为新生对象分配内存。对象所需内存大小在类加载完成后便可以确定。
1、java堆内存是规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，每次分配内存是把指针向空闲那边移动，这种分配的方式称为指针碰撞
2、不规整，已使用的内存和空闲的内存相互交错，虚拟机必须维护一个列表，记录那些内存块是可用的，在分配的时候从列表找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配的方式称"空闲列表"
java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
因此，在使用Serial、 ParNew等带Compact过程的收集器时，系统采用的分配算法是指针
碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表
分配内存并发问题：采用两种方式
1、对分配内存空间的动作进行同步处理
2、把内存分配的任务按照线程划分在不同的空间之中进行
第三步：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值
虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、 如何才能找到类的元数据信息、 对象的哈希码、 对象的GC分代年龄等信息

(2)对象的内存布局
对象在内存中存储的布局可以分为：对象头，实例数据和对齐填充
用于存储对象自身的运行时数据：
如哈希码，GC分代年龄，锁状态标示，线程持有的锁，偏向线程ID，偏向时间戳
用于存储类型指针：对象指向它的类元数据的指针
用于对齐填充的占位符

(3)对象的访问定位
目前主流的访问方式有使用句柄和直接指针两种

(4)OutOfMemoryError异常
(1) Java堆溢出: Java堆用于存储对象实例，只要不断地创建对象，并且保证GC  ROOTs到对象之间有可达路径来避免垃圾回收机制清除这些对象。
“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。
虚拟机的堆参数（-Xmx与-Xms）

(2) 虚拟机栈和本地方法栈溢出
栈容量只由-Xss参数
1、如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常
在多线程开发时注意：
操作系统分配给每个进程的内存是有限制的，譬如32位的Windows限制为2GB。 虚拟机提供了参数来控制Java堆和方法区的这两部分内存的最大值。
剩余的内存为2GB（操作系统限制）减去Xmx（最大堆容量），再减去MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略掉。
如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈“瓜分”了。
每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。

2、如果虚拟机在扩展是无法申请到足够的内存空间，则抛出OutOfMemberError异常

3、方法区和运行时常量池溢出
方法区异常：PermGen space
通过-XX：PermSize和-XX：MaxPermSize限制方法区大小
方法区用于存放Class的相关信息，如类名、 访问修饰符、 常量池、 字段描述、 方法描述等
当前的很多主流框架，如Spring、 Hibernate，在对类进行增强时，都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存

4、本机直接内存溢出
通过-XX：MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样

第3章 垃圾收集器与内存分配策略
(2) 对象是否存活
1、引用计数算法
Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象
之间相互循环引用的问题

2、可达性分析算法
通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所
走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用。
GC Roots
虚拟机栈（栈帧中的本地变量表）中引用的对象。
方法区中类静态属性引用的对象。
方法区中常量引用的对象。
本地方法栈中JNI（即一般说的Native方法）引用的对象

3 引用
强引用（Strong Reference）
类似“Object obj=new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象
软引用（Soft Reference）： 并非必需的对象
在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收
弱引用（Weak Reference）
弱引用关联的对象只能生存到下一次垃圾收集发生之前
虚引用（Phantom Reference）
无法通过虚引用来取得一个对象实例

4 生存还是死亡
即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。

5 回收方法区
废弃常量和无用的类
回收废弃常量与回收java堆中的对象非常类似
类需要同时满足下面3个条件才能算是“无用的类”：
(a)该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
(b)加载该类的ClassLoader已经被回收。
(c)该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该的方法。

(3) 垃圾收集算法
1、标记-清除算法 ：分为标记和清除两个阶段
它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是
空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程
序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾
收集动作

2、复制算法(新生代)
它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。
当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉
代价比较高： 将内存缩小为了原来的一半，未免太高了一点

HotSpot虚拟机默认将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。 当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。
HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。
当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion)

3、标记-整理算法（老年代）
“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

4、分代收集算法:是根据对象存活周期的不同将内存划分为几块
把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。
而老年代中因为对象存活率高、 没有额外空间对它进行分配担保，就必须使用“标记―清理”或者“标记―整理”算法来进行回收

(4) HotSpot的算法实现
1、枚举根节点 ： 在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举
2、安全点：只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停
有两种方案：抢先式中断（Preemptive Suspension）和主动式中断
在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。
3、安全区域：对于Sleep状态的线程，无法响应JVM的中断请求，进入安全点，所以要使用安全区域
在这个区域中的任意地方开始GC都是安全的。 我们也可以把Safe Region看做是被扩展了的Safepoin

(5) 垃圾收集器
新生代
1、Serial收集器：这个收集器是一个单线程的收集器，它只会使用一个CPU或一条收集线程去完成垃圾收集工作，并且在它进行垃圾收集时，必须停止其他所有的工作线程，直到它收集结束
2、ParNew收集器：ParNew收集器其实就是Serial收集器的多线程版本。只是GC是多线程处理，也会停顿用户线程
并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。
3、Parallel Scavenge收集器目标是达到一个可控制的吞吐量。
所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值.
老年代
1 Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法
2 Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法

*3 CMS收集器：是基于“标记―清除”算法实现的
分为以下4个步骤
初始标记、 重新标记这两个步骤仍然需要“Stop The World”
并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的

*4 G1: 是基于“标记―整理”算法(没有区分新生代和老年代)
G1收集器的运作大致可划分为以下几个步骤：
初始标记（Initial Marking）
并发标记（Concurrent Marking）
最终标记（Final Marking）
筛选回收（Live Data Counting and Evacuation）

(6) 内存分配与回收策略
给对象分配内存:
对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。
少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。

1 对象优先在Eden分配
对象在新生代Eden区中分配。
当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC
新生代GC（Minor GC）：
指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
老年代GC（Major GC/Full GC）：
指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。
Major GC的速度一般会比Minor GC慢10倍以上。

2 大对象直接进入老年代
虚拟机提供了一个-XX：PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配
这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制

3 长期存活的对象将进入老年代
虚拟机给每个对象定义了一个对象年龄（Age）计数器
如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。
对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中

4 动态对象年龄判定
如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄

5 空间分配担保
在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。
如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，
如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC

第4章 虚拟机性能监控与故障处理工具
一、JDK的命令行工具
1、jps -lvm：虚拟机进程状况工具

2、jstat 是用于监视虚拟机各种运行状态信息的命令行工具
-class 监视类装载、卸载数量、总空间以及类装载所耗费的时间
-gc 监视java堆状况，包括Eden区，两个surivor区，老年代，永久代等的容量，已用空间，GC时间合计等信息
-gcutil 监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比
 S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT
0.00  50.00   2.31  41.19  42.50    871   24.682     1    0.087   24.768

查询结果表明：这台服务器的新生代Eden区（E，表示Eden）使用了2.31%的空间，两个Survivor区（S0、 S1，表示Survivor0、 Survivor1）里面都是空的，
老年代（O，表示Old）和永久代（P，表示Permanent）则分别使用了41.19%和42.50%的空间。
程序运行以来共发生Minor GC（YGC，表示Young GC）871次，总耗时24.682秒，发生Full GC（FGC，表示FullGC）1次，
Full GC总耗时（FGCT，表示Full GC Time）为0.087秒，所有GC总耗时（GCT，表示GC Time）为24.768秒。

3、jinfo：作用是实时地查看和调整虚拟机各项参数

4 jmap: 命令用于生成堆转储快照

5 jhat的分析结果

6 jstack  命令用于生成虚拟机当前时刻的线程快照
jstack命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump 或javacore 文件）。
生成线程快照的主要目的是定位线程长时间停顿的原因，如线程间死锁，死循环，请求外部资源导致长时间等待都是导致线程长时间停顿的常见原因
参数
-F 当正常输出的请求不被响应时，强制输出线程堆栈
-l 除堆栈外，显示关于锁的附加信息
-m 如果调用到本地方法的话，可以显示C的堆栈

二 JDK的可视化工具



