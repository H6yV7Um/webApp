第10章 避免活跃性危险

1、死锁
当一个线程永远地持有一个锁，并且其他线程都尝试获得这个锁，那么他们将一直被阻塞
(1)数据库死锁的场景
在执行一个事务时可能需要获取多个锁，并一直持有这些锁直到事务提交。因此在两个事务之间很可能发生死锁。数据库会选择一个牺牲者并放弃这个事务。
牺牲者的事务会释放它所持有的资源，从而使其他事务继续进行。应用程序可以重新执行被强行中止的事务，而这个事务现在可以成功完成。

(2)JVM死锁
锁顺序死锁
A线程 -> 锁住left -> 尝试锁住right -> 永久等待
B线程 -> 锁住right -> 尝试锁住left -> 永久等待
如果保证所有线程获得锁顺序是一样的,就不会发生锁顺利死锁
解决办法：
可以使用System.identityHashCode来定义锁的顺序
可以使用加时锁

(3) 在协助对象之间发生的死锁 ： 使用开发调用的方式

(5) 资源死锁
场景1 ： 一个任务需要连接两个数据库，并且在请求这两个资源时，不会始终遵循相同的顺序，那么线程A可能持有与数据库D1连接，并等待与数据库D2的连接
而线程B可能持有与数据库D2连接，并等待与数据库D1的连接

场景2 ： 线程饥饿死锁 : 一个任务提交另一个任务，并等待被提交任务在单线程的Executor中执行完成.
这种情况下，第一个任务将永远等待下去，并使得另一个任务以及在这个Executor中执行的所有其他任务都停止执行

2、死锁的避免
如果一个程序每次至多只能获得一个锁，那么就不会产生锁顺序死锁
如果必须获取多个锁，那么设计时必须考虑锁的顺序

(1) 支持定时的锁
显示锁:可以指定一个超时时限，在等待超过时间后tryLock会返回一个失败信息。
(2) 通过线程转存信息来分析死锁
jvm可以通过转存来帮助识别死锁的发生。线程转储包括了线程的栈追踪信息，还包含加锁信息

3、饥饿、失去信号、活锁
(1) 饥饿 当线程由于无法访问它所需要的资源而不能继续执行时，就发生了"饥饿"
引发饥饿的最常见资源就是CPU时钟周期
(2) 活锁 不会阻塞线程，也不会继续执行，因为线程将不断重复执行相同的操作,最终会失败






