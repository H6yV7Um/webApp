第10章 避免活跃性危险

1、死锁
当一个线程永远地持有一个锁，并且其他线程都尝试获得这个锁，那么他们将一直被阻塞
(1)数据库死锁的场景
在执行一个事务时可能需要获取多个锁，并一直持有这些锁直到事务提交。因此在两个事务之间很可能发生死锁。数据库会选择一个牺牲者并放弃这个事务。
牺牲者的事务会释放它所持有的资源，从而使其他事务继续进行。应用程序可以重新执行被强行中止的事务，而这个事务现在可以成功完成。

(2)JVM死锁
锁顺序死锁
A线程 -> 锁住left -> 尝试锁住right -> 永久等待
B线程 -> 锁住right -> 尝试锁住left -> 永久等待
如果保证所有线程获得锁顺序是一样的,就不会发生锁顺利死锁
解决办法：
可以使用System.identityHashCode来定义锁的顺序
可以使用加时锁

(3) 在协助对象之间发生的死锁 ： 使用开发调用的方式

(5) 资源死锁
场景1 ： 一个任务需要连接两个数据库，并且在请求这两个资源时，不会始终遵循相同的顺序，那么线程A可能持有与数据库D1连接，并等待与数据库D2的连接
而线程B可能持有与数据库D2连接，并等待与数据库D1的连接

场景2 ： 线程饥饿死锁 : 一个任务提交另一个任务，并等待被提交任务在单线程的Executor中执行完成.
这种情况下，第一个任务将永远等待下去，并使得另一个任务以及在这个Executor中执行的所有其他任务都停止执行

2、死锁的避免
如果一个程序每次至多只能获得一个锁，那么就不会产生锁顺序死锁
如果必须获取多个锁，那么设计时必须考虑锁的顺序

(1) 支持定时的锁
显示锁:可以指定一个超时时限，在等待超过时间后tryLock会返回一个失败信息。
(2) 通过线程转存信息来分析死锁
jvm可以通过转存来帮助识别死锁的发生。线程转储包括了线程的栈追踪信息，还包含加锁信息

3、饥饿、失去信号、活锁
(1) 饥饿 当线程由于无法访问它所需要的资源而不能继续执行时，就发生了"饥饿"
引发饥饿的最常见资源就是CPU时钟周期
(2) 活锁 不会阻塞线程，也不会继续执行，因为线程将不断重复执行相同的操作,最终会失败

第11章 性能
LinkedBlockingQueue性能优于同步LinkedList时发生阻塞的可能性，因为LinkedBlockingQueue使用了一种可伸缩性更高的算法
同步的LinkedList采用单个锁来保护整个队列的状态，并且offer和remove等方法的调用期间都将持有这个锁
ConcurrentLinkedQueue 使用了复杂的非阻塞队列算法，串行操作范围小

一 线程引入的开销
1 上下文切换 : 线程切换使用CPU
2 内存同步
3 阻塞

二 减少锁的竞争
两个因素影响锁上发生竞争的可能性，锁的请求频率，以及每次持有该锁的时间。如果二者乘积很小，那么大多数获取锁的操作都不会发生竞争
(1) 减小锁的范围 :　可以将一些与锁无关的代码移出同步代码块
(2) 减少锁的粒度 ： 通过锁分解，采用多个相互独立的锁来保护独立的状态变量
锁分解
public class ServerStatus{
    public final Set<String> users;
    public final Set<String> queries;

    public void addUser(String u){
        synchronized(user){
            users.add(u)
        }
    }
    public void addQuery(String q){
        synchronized(queries){
            queries.add(q)
        }
    }
}
锁分段
ConcurrentHashMap的实现中使用了一个包含16个锁的数组，每个锁保护所有散列桶的16分之1的数据状态
如果分布均匀,ConcurrentHashMap能够支持16个并发写入线程
不足：当实现独占访问时，要获取多个锁，例如当ConcurrentHashMap扩展，重新计算散列值要分布更大的桶集合中
HashMap的put和get方法会更新一个计数器

(3)读写锁
ReadWriteLock
多个读取操作不会修改共享资源，那么这些读取操作可以同时访问该共享资源，但在执行写入操作时必须以独占方式来获取锁

第13章 显示锁
内置锁不足：
无法中断一个正在等待获取锁的线程
无法实现非阻塞结构的加锁规则
一、显示锁使用
1、Lock与ReentranLock:
使用ReentrantLock来保护对象的状态,必须自已手动释放锁
Lock lock = new ReentrantLock()
lock.lock();//加锁
try{

}finally{
    lock.unlock();//释放锁
}
而synchronized 获取的锁，在方法抛出异常的时候会自动解锁

2、轮询锁与定时锁
内置锁中，死锁时一个严重的问题，恢复程序的唯一方法是重新启动，而防止死锁的唯一方法就是在构造程序时避免出现不一致的锁顺序。
可定时和可轮询的锁提供另一种方式，避免死锁的发生,它会释放已经获得的锁，然后重新尝试获取所有锁

定时锁: 能在带有时间限制的操作中使用独占锁

3、可中断的锁获取操作
public boolean sendOnSharedLine(String message) throws InterruptedException{
    lock.lockInterruptibly();//可中断锁
    try{

    }finally{
        lock.unlock();
    }
}

二、公平性
在ReentrantLock的构造函数中提供了两种公平性的选择 ：
非公平锁 ： 当一个线程请求非公平的锁时，如果在发出请求的同时该锁的状态变为可用
那么这个线程将"插队"获得锁
公平锁 : 线程将按照它们发出请求的顺序来获得锁
一般非公平锁，性能高与公平锁
原因：
公平锁由于在挂起线程和恢复线程时存在的开销而极大地降低性能
例如 非公平锁的这样挂起和恢复
A线程持有锁，B请求这个锁时会被挂起，当A释放锁时，B唤醒，再次尝试获取锁，这时C也请求这个锁
那么C可能在B被完全唤醒前，就执行完，B获得锁再执行
如果是公平锁，那么C的请求锁顺序再B后，就不能交替执行。吞吐量小















