基础

Java内存模型
所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享
局部变量、方法参数、异常处理参数 不会共享

一、java线程之间的通信有java内存模型控制
JMM决定一个线程对共享变量的写入何时对另一个线程可见
JMM定义了线程和主内存之间的抽象关系：
线程之间的共享变量存储在主内存中，每个线程有一个私有的本地内存，
本地内存中存储了该线程以读/写共享变量的副本。

二、线程A与线程B通信步骤
1、线程A把本地内存A中更新过的共享变量刷新到主内存中
2、线程A给线程B发消息，线程B到主内存中读取线程A之前已更新过的共享变量

三、重排序 ：编译器和处理器会对指令做重排序
1、编译器优化的重排序：在不改变单线程语义的前提下，可以重新安排语句的执行顺序
2、指令级并行的重排序: 现在处理器采用了指令级并行技术来将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序
3、内存系统的重排序：由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行
源代码都要经历上面3步后，成为最终的执行指令的序列
上面的重排序可能会导致多线程程序出现内存可见性问题
JMM:对于编译器排序规则会禁止特定类型的编译器重排序
JMM:对于处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏蔽指令，禁止特定类型的处理器重排序

四、处理器重排序与内存屏障指令
为了保证内存可见性: java编译器在生成指令序列的适当位置会插入内存屏蔽指令来禁止特定类型的处理器重排序
JMM内存屏障指令
1: LoadLoad   确保Load1数据装载，之前于Load2及所有后续装载指令的装载。
2: StoreStore 确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储。
3: LoadStore  确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。
4: StoreLoad  确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载

五、happens-before
从JDK5开始,java使用新的JSR-133内存模型，该模型使用happens-before的概念阐述操作之间的内存可见性。
JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系
happens-before 规则如下
程序顺序规则 ：一个线程中的每个操作，happens-before于该线程中的任意后续操作
监视器锁规则 : 一个监视器的锁，happens-before 于随后对这个监视器的加锁
volatile变量规则 ： 对一个volatile域的写，happens-before 于任意后续对这个volatile域的读
传递性 如果A happens-before B，且B happens-before C ，那么A happens-before C

六 重排序
数据依赖性 : 只有在单线程中可以保证
如果两个操作访问同一个变量，且这两个操作中有一个写操作，此时这两个操作之间就存在数据依赖性
as-if-serial语义: 使单线程无需担心重排序会干扰他们，也无需担心内存可见性问题

程序顺序规则
double pi = 3.14 //A
double r = 1.0 //B
double area = pi * r * r //C
根据happens-before的程序顺序规则，上面代码存在三个happens-before关系
1 A happens-before B
2 B happens-before C
3 A happens-before C
这里的第3个 happens-before关系，是根据happens-before的传递性得来的

这里A happens-before B，但实际执行时B却可以排在A之前执行。
因为A happens-before B，JMM并不要求A一定要在B之前执行，JMM仅仅要求前一个操作对后一个操作可见，且前一个操作
按顺序排在第二个操作之前。

重排序对多线程的影响
public class Reorder {
    int a = 0;
    boolean flag = false;

    public void writer(){
        a = 1;//操作1
        flag = true;//操作2
    }
    操作1和操作2没有数据依赖关系，编译器和处理器可以对两个操作重排序
    public void reader(){
        if (flag)//操作3
        {
            int i  = a*a ;//操作4
        }
    }
    同样操作3和操作4没有数据依赖关系，编译器和处理器可以对两个操作重排序
}

七、顺序一致性
数据竞争与顺序一致性保证
如果一个多线程程序能正确同步，就不会有数据竞争

顺序一致性内存模型特点
一个线程中的所有操作必须按照程序员的顺序来执行。
所有线程都只能看到一个单一的操作执行顺序,在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见
下面多个线程，只能一个在一个时间，访问全局内存
线程1   线程2   线程3    线程4
         |
         |
         |
      全局内存

同步程序的顺序一致性效果

未同步程序的执行特性
对于未同步或未正确同步的多线程程序
JMM只提供最小安全性：
线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值
(1) 顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行
(2) 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序
(3) JMM不保证对64位的long型和double型变量的读/写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性
在32位的处理器，如果要求对64位数据的写操作具有原子性，会有比较大的开销。
所以JVM在这种处理器上运行时，会把一个64位long/double型变量的写操作拆分为两个32位写操作来执行
这两个32位写操作可能会被分配到不同的总线事务中执行，此时对这个64位变量的写将不具有原子性

八 volatile
volatile的特性: 对一个volatile变量的读，总是能看到对这个volatile变量最后的写入
volatile具有可见性，但volatile++这种复合操作不具有原子性

volatile写-读建立的happens before关系

volatile写-读的内存语义
volatile写的内存语义如下
(1) 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存

(2) 当读一个volatile变量时，JMM会把线程对应的本地内存置为无效。线程从主内存中读取变量
总结
线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了消息
线程B读一个volatile变量，实现上是B接收了某个线程发出的消息
线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发消息

volatile内存语义的实现 ： 在编译器生成字节码时，会在指令序列中插入内存屏障来禁止处理器重排序
(1)在volatile写前添加：StoreStore屏障 ;在写后添加：StoreLoad屏障
(2)在volatile后前添加1：LoadLoad屏障 ;在写后添加2：LoadStore屏障

九 锁
锁释放-锁获取的happens before关系

锁释放和获取的内存语义
1 当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中
2 当线程获取锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取变量

总结：
线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了消息
线程B获得一个锁，实质上是线程B接收了之前某个线程发出的消息
线程A释放锁，随后线程B获取这个锁，这个过程实质上线程A通过主内存向线程B发送消息

锁内存语义实现

十 final
与前面介绍的锁和volatile相比，对final域的读和写更像是普通的变量访问
对于final，编译器和处理器要遵守重排序规则
1 写final域的重排序规则
确保在对象引用为任意线程可见之前，对象的final域已经正确的初始化过了

2 读final域的重排序规则
确保在读一个对象的final域之前，一个会先读包含这个final域的对象的引用。


