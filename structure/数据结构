一 线性表 : 零个或多个数据元素的有限序列
1 顺序存储结构
优点 无须为表示表中元素之间的逻辑关系而增加额外的存储空间,取表中任一个位置的元素时间复杂度低O(1)
缺点 每次插入和删除元素时间复杂度O(n)

2 链式
重点: 除了要存储元素本身,还需要存储元素后继元素的地址(也就是一个指针)
数据查询时间复杂度O(n)
每次插入和删除元素时间复杂度O(1)
typed struct Node
{
    ElemType data; 当前元素
    struct Node *next;  后继指针
} Node;
typedef struct Node *LinkList;

插入节点s：
    s - > next = p -> next;
    p - > next = s;

3 静态链表 : 让一个数组元素都是由两个数据域组成,data和cur ()
  数据结构如下
    typedef struct
    {
        ElemType data;
        int cur;//游标
    }
优点:
    在插入和删除操作时,只需要修改游标,不需要移动元素,插入和删除元素时间复杂度O(1)
    可以通过数组下标直接取数,取表中任一个位置的元素时间复杂度低O(1)

4 循环链表
  单链表中的终端结点的指针由空指针改为指向头结点,就使整个单链表形成一个环。

  单链表的差异在于循环结束的判断不同
    原来是判断p->next不为空
    现在是判断p->next不等于头结点

5 双向链表
  在单链表的每个结点中,再设置一个指向其前驱结点的指针域,包含两个指针域,前驱和后继
    双向循环链表
    对于链表中的某个结点p,它的后继的前驱,以及前驱的后继,都是它本身
    判断循环结束,和单向循环链表一样

插入节点s：
    s - > prior = p;
    s - > next = p -> next;
    p - > next - > prior = s;
    p - > next = s;

二 栈与队列
栈 : 仅在表尾进行插入和删除操作的线性表
    1 栈的顺序存储结构 : 基于数组

    2 栈的链式存储结构 : 对于空栈来说,链表定义是头指针指向空
    3 栈的应用
        递归:
            一定要有递归结束条件
        四则运算表达式求值 :
            先将操作数进栈,遇到操作符出栈进行计算,再把计算进栈
    4 栈 出栈的时候,不需要移动元素

队列 : 在一端进行插入,在另一端进行删除的线性表
    先进先出
    1 队列的顺序存储结构
        入队列,不需要移动任何元素,时间复杂度O(1),
        出队列,所有元素都得向前移动,时间复杂度O(n)。
        为了避免出队列，所有元素都向前移动。
        队列中使用两个指针,front指针指向对头元素,rear指针指向对尾元素的下一个位置
        空队列 front = rear
        循环队列:把队列的这种头尾相接的顺序存储结构称为循环队列
            为了避免有空闲位置，但存入不了的情况。
        rear+1%queueSize == front

    2 队列的链式存储结构
        其实就是线性表的单链表,但只能从队尾插入元素，从队头删除元素

三 串
    1 串的比较是通过组成串的字符之间的编码来进行的,而字符的编码指的是字符在对应字符集的序号
    2 串的顺序存储结构 是用一组地址连续的存储单元来存储串中的字符序列
    3 串的链式存储结构

四 树
1  树是n(n>=0)个结点的有限集.n=0时,称为空树,在任意一棵非空树中
    (1)有且仅有一个特定的称为根的结点
    (2)当n>1时,其余结点可分为m(m>0)个互不相交的有限集

2 树的结点
    结点拥有的子树数称为结点的度,度为0的结点称为叶结点或终端结点
    结点包括父子,兄弟,祖先
    结点的层次 : 根为第一层,往下层数加1
    树中结点的最大层次称为树的深度
    树中结点的各子树看成从左至右是有次序的,不能互换,则称该树为有序树

3 树的存储结构
    (1) 双亲表示法 : 在每个节点中,附设一个指示器指示其双亲结点在数组中的位置(data parent)
        其中data是数据域,存储结点的数据信息,而parent是指针域,存储该结点的双亲在数组中的下标
    (2) 孩子表示法 : 是数组和链表的组合结构
    (3) 孩子兄弟表示法

4 二叉树的定义
    特点:
    (1) 每个结点最多有两棵子树
    (2) 左子树和右子树是有顺序的
    (3) 满二叉树 : 如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层。
    (4) 完全二叉树 : 下面就是列子
            1
         2     3
       4  5   6  7
      8 9

5 二叉链表 :
    二叉树每个结点最多有两个孩子,所以为它设计一个数据域和两个指针域

6 遍厉二叉树
    a : 前序遍历
    b : 中序遍厉
    c : 后序遍厉
    d : 层序遍厉

7 二叉树的建立

8 线索二叉树

9 树 森林与二叉树的转换
    树转二叉树的过程
        (1) 给兄弟加线
        (2) 去掉除长子以外的孩子与父子的线

    森林转二叉树
        (1) 先将每棵树转换为二叉树
        (2) 将所有二叉树转换为一棵二叉树

10 二叉树转换树为树
    (1) 如果某个结点的左孩子结点存在,将左孩子结点的右孩子结点,连接到这个这点上
    (2) 去掉原来所有右结点的连接

11 二叉树转换森林
    (1) 从根结点开始,判断右结点是否存在,存在的话,就去掉右连接

12 赫夫曼树
    (1) 从树中一个结点到另一个结点之间的分支构成两个结点之间的路径,路径上的分支数目称做路径长度
        树的路径长度就是从树根到每一结点的路径长度之和

    (2)带权路径长度最小的二叉树称做赫夫曼树

五 图 G = {V1 E1}
(1) 概念: 是由顶点的有穷非空集合和顶点之间边的集合组成,通常表示为:G(V,E) 其中 G表示一个图,V是图G中顶点的集合,E是图G中边的集合
    1 无向图 : 任意两个顶点之间的边都是无向边
    2 有向图 : 任意两个顶点之间的边都是有向边
    3 子图: 无向图和有向图
    4 有向图路径
    5 简单环 :
    6 连通图(针对无向图) : 如果对于图中任意两个顶点都是连通的,则称G是连通图
    7 强连通图(针对有向图) : 如果对于每一对vi,vj,从vi到vj和从vj到vi都存在路径,则称G是强连通图

(2) 图的存储结构
1 邻接矩阵
顶点: 用一个一维数组来存储
边: 由于描述顶点和顶点的关系,使用一个二维数组
如下无向图
顶点数组 : v0,v1,v2,v3

边         v0 v1 v2 v3
      v0   0  1  1  1
      v1   1  0  1  0
      v2   1  1  0  1
      v3   1  0  1  0

有向图 v0-v1没有边;而v1-v0都有边
顶点数组 : v0,v1,v2,v3

边        v0 v1 v2 v3
       v0 0  0  0  1
       v1 1  0  1  0
       v2 1  1  0  0
       v3 0  0  0  0

网: 矩阵的取值范围有(0,权值,无穷大)
顶点数组 : v0,v1,v2,v3,v4

边:       v0 v1 v2 v3 v4
      v0  0  +  +  +  6
      v1  9  0  3  +  +
      v2  2  +  0  5  +
      v3  +  +  +  0  1
      v4  +  +  +  +  0

2 邻接表 数组与链表相结合的存储方法称为邻接表
    无向图
    0 v0 -> 1 -> 2 - 3 (指向的链表中是数组中的下标)
    1 v1 -> 0 -> 2
    2 v2 -> 0 -> 1
    3 v3 -> 0 -> 2

    有向图(与无向图相似,只是注意方向)

网
    0 v0 -> (4,'6') 第一个值是下标,第二个值是权重
    1 v1 -> (0,'6') -> (2,'3')
    2 v2 -> (0,'2') -> (3,'5')
    3 v3 -> (4,'1')
    4 v4

十字链表
    邻接多重表
    边集数组

(3)图的遍历
    深度优先遍历 : 以右手边为原则,全部走完,看是否所有顶点都走到,没有走到则回退一步,查看是否有顶点没走到,有的话就走到该结点,否则再退一步,直到所有结点都遍历完

    广度优先遍历 :


第六章
    查找 :就是根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素

2 查找表按照操作方式来分有两大种: 静态查找表和动态查找表
    静态查找表 : 只作查找操作的查找表
        (1) 查询某个特定的数据元素是否在查找表中
        (2) 检索某个特定的数据元素和各种属性
    动态查找表 :
        (1) 查找是插入数据元素
        (2) 查找是删除数据元素

3 顺序查找 : 时间复杂度O(n)

4 有序表查找
    (1) 折半查找(二分查找) 前提是线性表中的记录是有序的 时间复杂度O(logN)
    (2) 插值查找

5 线性索引查找 : 分为稠密索引,分块索引,倒排索引
    (1) 稠密索引 : 将数据集中的每个记录对应一个索引项,索引项一定是按照关键吗有序的排序
    (2) 分块索引 : 先在分块索引表查找,再到指向的数据块中查找
    (3) 倒排索引 : 用于索引技术
        存储具有相同次关键字的所有记录的记录号,这样的索引方法就是倒排索引

6 二叉排序树 : 以链式方式存储,保证插入和删除结点不用移动元素,查找给看树的深度而定(后续平衡二叉树为了解决查询性能而引入的)
    若它的左子树不空,则左子树上所有结点的值均小于它的根结构的值,右子树不空,则右子树所有的值大于它的根结点
    二叉树查找:采用了递归的定义方法

二叉树插入:

二叉树删除:
    叶子结点,仅有左和右子树结点,左右子树都有结点


7 平衡二叉树 : 是一种二叉树,其中每一个节点的左子树和右子树高度差不能大于1(也是就是平衡因子绝对值不能大于1)
  通过平衡因子,找到最小非平衡二叉树,通过对非平衡二叉树左旋转或右旋转称为平衡二叉树

8 多路查找树(B树) :
B树 : 存储结构如下 : "_" 表示指针
      _ 8 _
   |        |
 _ 4 _    _ 12 _ 14 _

B树的不足:对于树结构来说,我们都可以通过中序遍历来顺序查找树中的元素,这是在内存中进行的.可在B树结构中,我们往返于每个结点之间也就意味着,我们必须得在硬盘进行多次访问

B+树 存储结构 : 分支结点中的元素会被当作它们在该结点位置的中序后继者中再次列出

      3     5    8
    |       |    |
  1 2 3->  4 5->6 7 8 -> 9
B+ 适合带有范围的查找

9 散列表查找(哈希表)概述
  散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f,使得每个关键字key对应一个存储位置f(key),f称为哈希Hash函数

  采用散列技术将记录存储在一块连续的存储空间中,这块连续存储空间称为散列表

  散列函数的构造方法
    (1)直接定址法 f(key) = a * key + b
    (2)数字分析法
    (3)平方取中法
    (4)折叠法
    (5)除留余数法
    (6)随机数法

  处理散列冲突的方法
    (1)开放定址法 : 一但发生冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找到
    (2)再散列函数法
    (3)链地址法 HashMap才用的正是这样的方法
    (4)公共溢出区 : 冲突的元素单独放在溢出表中

散列表查找实现

散列表查找性能分析 : 没有冲突,散列查找时间复杂度O(1)
    1 散列函数是否均匀
    2 处理冲突的方法
    3 散列表的装填因子


第9章 排序

内排序与外排序
内排序是在排序整个过程中,待排序的所有记录全部被放置在内存中.排序算法的性能主要是受3个方面影响
(1) 时间性能 高效率的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数
(2) 辅助空间
(3) 算法的复杂性

1 冒泡排序 : 两两比对
时间复杂度O(n*n)
public class BubbleSort {
    public static void main(String[] args) {

        int [] a = new int[]{4,2,3,1,7,6,9,8};
        for (int i = 0 ; i<a.length;i++){
            for (int j = i+1 ; j<a.length;j++){

                if (a[j] < a[i] ){

                    int temp = a[j];

                    a[j] = a[i];

                    a[i] = temp;
                }
            }
        }
    }
}

2 选择排序 : 先选i个元素,设置为最小,比较n-i+1元素,如果找出比i元素小的元素,交换
时间复杂度 O(n*n)
public class SelectSort {
    public static void main(String[] args) {
        int [] a = new int[]{3,2,4,1,7,5,6,9,8};

        int min = -1;

        for (int i=0; i< a.length;i++){
            min = i;//最次都选小

            for (int j = i ; j<a.length;j++){
                if (a[min] > a[j]){
                    min = j;
                }
            }
            if (i!= min){
                int temp = a[i];
                a[i] = a[min];
                a[min] = temp;
            }
        }
        for ( int i = 0 ; i < a.length ; i++) {
            System.out.println(a[i]);
        }
    }
}

3 插入排序: 为当前值找到插入位置
public class InsertSort {
    public static void main(String[] args) {
        int i,j;

        int [] a = new int[]{3,2,4,1,7,6,9,8};
        for ( i = 1; i < a.length; i++) {
            int currentValue = a[i];
            int position = i;
            for ( j = i - 1; j >= 0; j--) {
                if (a[j] > currentValue) {
                    a[i] = a[j]; //前面的值向后移动
                    position --;
                } else {
                    break;
                }
            }
            a[position] = currentValue;//为当前值找到插入位置
        }
    }
}

4 希尔排序
public class ShellSort {
    public static void main(String[] args) {
        int [] data = new int[]{3,2,4,1,7,5,6,9,8};
        int h = 1;
        while (h <= data.length / 3) {
            h = h * 3 + 1;
        }
        while (h > 0) {
            for (int i = h; i < data.length; i += h) {
                if (data[i] < data[i - h]) {
                    int tmp = data[i];
                    int j = i - h;
                    while (j >= 0 && data[j] > tmp) {
                        data[j + h] = data[j];
                        j -= h;
                    }
                    data[j + h] = tmp;
                }
            }
            // 计算出下一个h值
            h = (h - 1) / 3;
        }
    }
}

5 堆排序
构造二叉树
时间复杂度O(nlogn)

6 归并排序
时间复杂度O(nlogn)

7 插入排序
时间复杂度O(nlogn)


外排序是由于排序的记录个数太多,不能同时放置在内存,整个排序过程需要在内外存之间多次数据交换才能进行


































