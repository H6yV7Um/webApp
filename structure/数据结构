一 线性表 : 零个或多个数据元素的有限序列
1 顺序存储结构
优点 无须为表示表中元素之间的逻辑关系而增加额外的存储空间,取表中任一个位置的元素时间复杂度低O(1)
缺点 每次插入和删除元素时间复杂度O(n)

2 链式
重点: 除了要存储元素本身,还需要存储元素后继元素的地址(也就是一个指针)
数据查询时间复杂度O(n)
每次插入和删除元素时间复杂度O(1)
3 静态链表 : 让一个数组元素都是由两个数据域组成,data和cur ()
数据结构如下
typedef struct
{
    ElemType data;
    int cur;//游标
}
优点:
在插入和删除操作时,只需要修改游标,不需要移动元素,插入和删除元素时间复杂度O(1)
可以通过数组下标直接取数,取表中任一个位置的元素时间复杂度低O(1)

4 循环链表 单链表中的终端结点的指针有空指针改为指向头结点,就使整个单链表形成一个环.
与单链表的差异在于循环结束的判断上
原来是判断p->next不为空
现在是p->next不等于头结点

5 双向链表 在单链表的每个结点中,再设置一个指向其前驱结点的指针域,包含两个指针域,前驱和后继
双向循环链表
对于链表中的某个结点p,它的后继的前驱,以及前驱的后继,都是它本身
判断循环结束,于单向循环链表一样

二 栈与队列

栈 : 仅在表尾进行插入和删除操作的线性表
1 栈的顺序存储结构 : 基于数组

2 两栈共享空间 :  top1 + 1 = top2 当栈1的指针等于栈2的指针时,表示栈已经满了

3 栈的链式存储结构 : 对于空栈来说,链表定义是头指针指向空

4 栈的应用
递归
四则运算表达式求值 : 先将操作数进栈,遇到操作符出栈进行计算,再把计算进栈

5 栈出栈的时候,不需要移动元素

队列 : 在一端进行插入,在另一端进行删除的线性表
先进先出
1 队列的属性存储结构
入队列,不需要移动任何元素,时间复杂度O(1),出队列是,所有元素都得向前移动,时间复杂度O(n)
队列中使用两个指针,front指针指向对头元素,rear指针指向对尾元素的下一个位置
非循环队列 : 空队列 front = rear
2 循环队列 把队列的这种头尾相接的顺序存储结构称为循环队列
rear+1%queueSize == front

3 队列的链式存储结构,其实就是线性表的单链表,但只能尾进头出

三 串
1 串的比较是通过组成串的字符之间的编码来进行的,而字符的编码指的是字符在对应字符集的序号
2 串的顺序存储结构 是用一组地址连续的存储单元来存储串中的字符序列
3 串的链式存储结构

四 树
1  树是n(n>=0)个结点的有限集.n=0时,称为空树,在任意一棵非空树中
(1)有且仅有一个特定的称为根的结点
(2)当n>1时,其余结点可分为m(m>0)个互不相交的有限集

2 树的结点
结点拥有的子树数称为结点的度,度为0的结点称为叶结点或终端结点

结点包括父子,兄弟,祖先

结点的层次 : 根为第一层,往下层数加1

树中结点的最大层次称为树的深度

树中结点的各子树看成从左至右是有次序的,不能互换,则称该树为有序树

3 数的存储结构
(1) 双亲表示法 : 在每个节点中,附设一个指示器指示其双亲结点在数组中的位置
(data parent)
其中data是数据域,存储结点的数据信息,而parent是指针域,存储该结点的双亲在数组中的下标
(2) 孩子表示法 : 是数组和链表的组合结构
(3) 孩子兄弟表示法

4 二叉树的定义
特点
(1) 每个结点最多有两棵子树
(2) 左子树和右子树是有顺序的
(3) 满二叉树
(4) 完全二叉树 : 与同样深度的满二叉树是一样的
5 二叉链表 : 二叉树每个结点最多有两个孩子,所以为它设计一个数据域和两个指针域
6 遍厉二叉树
a : 前序遍历
b : 中序遍厉
c : 后序遍厉
d : 层序遍厉

7 二叉树的建立

8 线索二叉树

9 树 森林与二叉树的转换
树转二叉树的过程
(1) 给兄弟加线
(2) 去掉除长子以外的孩子与父子的线

森林转二叉树
(1) 先将每棵树转换为二叉树
(2) 将所有二叉树转换为一棵二叉树

10 二叉树转换树为树
(1) 如果某个结点的左孩子结点存在,将左孩子结点的右孩子结点,连接到这个这点上
(2) 去掉原来所有右结点的连接

11 二叉树转换森林
(1) 从根结点开始,判断右结点是否存在,存在的话,就去掉右连接

12 赫夫曼树
(1) 从树中一个结点到另一个结点之间的分支构成两个结点之间的路径,路径上的分支数目称做路径长度
树的路径长度就是从树根到每一结点的路径长度之和

(2)带权路径长度最小的二叉树称做赫夫曼树

五 图 G = {V1 E1}
(1) 概念: 是由顶点的有穷非空集合和顶点之间边的集合组成,通常表示为:G(V,E) 其中 G表示一个图,V是图G中顶点的集合,E是图G中边的集合
1 无向图 : 任意两个顶点之间的边都是无向边
2 有向图 : 任意两个顶点之间的边都是有向边
3 子图: 无向图和有向图
4 有向图路径
5 简单环 :
6 连通图(针对无向图) : 如果对于图中任意两个顶点都是连通的,则称G是连通图
7 强连通图(针对有向图) : 如果对于每一对vi,vj,从vi到vj和从vj到vi都存在路径,则称G是强连通图

(2) 图的存储结构
1 邻接矩阵
顶点: 用一个一维数组来存储
边: 由于描述顶点和顶点的关系,使用一个二维数组
如下无向图
顶点数组 : v0,v1,v2,v3

边         v0 v1 v2 v3
      v0   0  1  1  1
      v1   1  0  1  0
      v2   1  1  0  1
      v3   1  0  1  0

有向图 v0-v1没有边;而v1-v0都有边
顶点数组 : v0,v1,v2,v3

边        v0 v1 v2 v3
       v0 0  0  0  1
       v1 1  0  1  0
       v2 1  1  0  0
       v3 0  0  0  0

网: 矩阵的取值范围有(0,权值,无穷大)
顶点数组 : v0,v1,v2,v3,v4

边:       v0 v1 v2 v3 v4
      v0  0  +  +  +  6
      v1  9  0  3  +  +
      v2  2  +  0  5  +
      v3  +  +  +  0  1
      v4  +  +  +  +  0

2 邻接表 数组与链表相结合的存储方法称为邻接表
无向图
0 v0 -> 1 -> 2 - 3 (指向的链表中是数组中的下标)
1 v1 -> 0 -> 2
2 v2 -> 0 -> 1
3 v3 -> 0 -> 2

有向图(与无向图相似,只是注意方向)

网

0 v0 -> (4,'6') 第一个值是下标,第二个值是权重
1 v1 -> (0,'6') -> (2,'3')
2 v2 -> (0,'2') -> (3,'5')
3 v3 -> (4,'1')
4 v4

十字链表

邻接多重表

边集数组

(3)图的遍历
深度优先遍历 : 以右手边为原则,全部走完,看是否所有顶点都走到,没有走到则回退一步,查看是否有顶点没走到,有的话就走到该结点,否则再退一步,直到所有结点都遍历完

广度优先遍历 :


第六章
查找 : 就是根据给定的某个值,在查找表中确定一个其关键字等于给定值得数据元素

2 查找表按照操作方式来分有两大种: 静态查找表和动态查找表
静态查找表 : 只作查找操作的查找表
(1) 查询某个特定的数据元素是否在查找表中
(2) 检索某个特定的数据元素和各种属性
动态查找表 :
(1) 查找是插入数据元素
(2) 查找时删除数据元素

3 顺序查找 :  时间复杂度O(n)

4 有序表查找
(1) 折半查找(二分查找) 前提是线性表中的记录是有序的 时间复杂度O(logN)

(2) 插值查找

5 线性索引查找 : 分为稠密索引,分块索引,倒排索引
(1) 稠密索引 : 将数据集中的每个记录对应一个索引项,索引项一定是按照关键吗有序的排序
(2) 分块索引 :
先在分块索引表查找,再到指向的数据块中查找
(3) 倒排索引 : 用于索引技术
存储具有相同次关键字的所有记录的记录号,这样的索引方法就是倒排索引

6 二叉排序树 : 




































