一 线性表 : 零个或多个数据元素的有限序列
1 顺序存储结构
优点 无须为表示表中元素之间的逻辑关系而增加额外的存储空间,取表中任一个位置的元素时间复杂度低O(1)
缺点 每次插入和删除元素时间复杂度O(n)

2 链式
重点: 除了要存储元素本身,还需要存储元素后继元素的地址(也就是一个指针)
数据查询时间复杂度O(n)
每次插入和删除元素时间复杂度O(1)
3 静态链表 : 让一个数组元素都是由两个数据域组成,data和cur ()
数据结构如下
typedef struct
{
    ElemType data;
    int cur;//游标
}
优点:
在插入和删除操作时,只需要修改游标,不需要移动元素,插入和删除元素时间复杂度O(1)
可以通过数组下标直接取数,取表中任一个位置的元素时间复杂度低O(1)

4 循环链表 单链表中的终端结点的指针有空指针改为指向头结点,就使整个单链表形成一个环.
与单链表的差异在于循环结束的判断上
原来是判断p->next不为空
现在是p->next不等于头结点

5 双向链表 在单链表的每个结点中,再设置一个指向其前驱结点的指针域,包含两个指针域,前驱和后继
双向循环链表
对于链表中的某个结点p,它的后继的前驱,以及前驱的后继,都是它本身
判断循环结束,于单向循环链表一样

二 栈与队列

栈 : 仅在表尾进行插入和删除操作的线性表
1 栈的顺序存储结构 : 基于数组

2 两栈共享空间 :  top1 + 1 = top2 当栈1的指针等于栈2的指针时,表示栈已经满了

3 栈的链式存储结构 : 对于空栈来说,链表定义是头指针指向空

4 栈的应用
递归
四则运算表达式求值 : 先将操作数进栈,遇到操作符出栈进行计算,再把计算进栈

5 栈出栈的时候,不需要移动元素

队列 : 在一端进行插入,在另一端进行删除的线性表
先进先出
1 队列的属性存储结构
入队列,不需要移动任何元素,时间复杂度O(1),出队列是,所有元素都得向前移动,时间复杂度O(n)
队列中使用两个指针,front指针指向对头元素,rear指针指向对尾元素的下一个位置
非循环队列 : 空队列 front = rear
2 循环队列 把队列的这种头尾相接的顺序存储结构称为循环队列
rear+1%queueSize == front

3 队列的链式存储结构,其实就是线性表的单链表,但只能尾进头出

三 串
1 串的比较是通过组成串的字符之间的编码来进行的,而字符的编码指的是字符在对应字符集的序号
2 串的顺序存储结构 是用一组地址连续的存储单元来存储串中的字符序列
3 串的链式存储结构

四 树
1  树是n(n>=0)个结点的有限集.n=0时,称为空树,在任意一棵非空树中
(1)有且仅有一个特定的称为根的结点
(2)当n>1时,其余结点可分为m(m>0)个互不相交的有限集

2 树的结点
结点拥有的子树数称为结点的度,度为0的结点称为叶结点或终端结点

结点包括父子,兄弟,祖先

结点的层次 : 根为第一层,往下层数加1

树中结点的最大层次称为树的深度

树中结点的各子树看成从左至右是有次序的,不能互换,则称该树为有序树

3 数的存储结构
(1) 双亲表示法 : 在每个节点中,附设一个指示器指示其双亲结点在数组中的位置
(data parent)
其中data是数据域,存储结点的数据信息,而parent是指针域,存储该结点的双亲在数组中的下标
(2) 孩子表示法 : 是数组和链表的组合结构
(3) 孩子兄弟表示法

4 二叉树的定义
特点
(1) 每个结点最多有两棵子树
(2) 左子树和右子树是有顺序的
(3) 满二叉树
(4) 完全二叉树 : 与同样深度的满二叉树是一样的
5 二叉链表 : 二叉树每个结点最多有两个孩子,所以为它设计一个数据域和两个指针域
6 遍厉二叉树
a : 前序遍历
b : 中序遍厉
c : 后序遍厉
d : 层序遍厉

7 二叉树的建立

8 线索二叉树

9 树 森林与二叉树的转换
树转二叉树的过程
(1) 给兄弟加线
(2) 去掉除长子以外的孩子与父子的线

森林转二叉树
(1) 先将每棵树转换为二叉树
(2) 将所有二叉树转换为一棵二叉树

10 二叉树转换树为树
(1) 如果某个结点的左孩子结点存在,将左孩子结点的右孩子结点,连接到这个这点上
(2) 去掉原来所有右结点的连接

11 二叉树转换森林
(1) 从根结点开始,判断右结点是否存在,存在的话,就去掉右连接

12 赫夫曼树
(1) 从树中一个结点到另一个结点之间的分支构成两个结点之间的路径,路径上的分支数目称做路径长度
树的路径长度就是从树根到每一结点的路径长度之和

(2)带权路径长度最小的二叉树称做赫夫曼树





















