第一章 概 论

线性结构：多对多关系。
    ·存储结构：是逻辑结构用计算机语言的实现。
    ·顺序存储结构：如数组。
    ·链式存储结构：如链表。
    ·索引存储结构：·稠密索引：每个结点都有索引项。
    ·稀疏索引：每组结点都有索引项。
    ·散列存储结构：如散列表

对数据的操作。定义在逻辑结构上，每种逻辑结构都有一个运算集合。
    ·常用的有：检索、插入、删除、更新、排序。

数据类型：是一个值的集合以及在这些值上定义的一组操作的总称

时间复杂度：是某个算法的时间耗费，它是该算法所求解问题规模n的函数
    时间复杂度按数量级递增排列依次为：
    常数阶O（1）、对数阶O（log2n）、线性阶O（n）、线性对数阶O（nlog2n）、平方阶O（n^2）、立方阶O（n^3）、……k次方阶O（n^k）、指数阶O（2^n）

空间复杂度：是某个算法的空间耗费，它是该算法所求解问题规模n的函数

第二章 线性表

线性表是由n≥0个数据元素组成的有限序列。  n=0是空表；非空表，只能有一个开始结点，有且只能有一个终端结点

顺序存储结构: 顺序表是按线性表的逻辑结构次序依次存放在一组地址连续的存储单元中。在存储单元中的各元素的物理位置和 逻辑结构中各结点相邻关系是一致的
链式存储结构: 在存储每个结点值的同时，还存储了其后继结点的地址信息
     ·头插法：s->next=head；head=s；生成的顺序与输入顺序相反。平均时间复杂度均为O（n）
     ·尾插法：head=rear=null；if（head=null） head=s；else r->next=s；r=s； 平均时间复杂度均为O（n）
     ·插入运算：p=GetNode（L，i-1）；s->next=p->next；p->next=s；平均时间复杂度均为O（n）
     ·删除运算：p=GetNode（L，i-1）；r=p->next；p->next=r->next；free（r）；平均时间复杂度均为O（n）
单循环链表是一种首尾相接的单链表，终端结点的指针域指向开始结点或头结点。链表终止条件是以指针等于头指针或尾指针。 采用单循环链表在实用中多采用尾指针表示单循环链表。优点是查找头指针和尾指针的时间都是O（1），不用 遍历整个链表
双链表就是双向链表，就是在单链表的每个结点里再增加一个指向其直接前趋的指针域prior，形成两条不同方向的链。由头指针head惟一确定
双链表上的插入和删除时间复杂度均为O（1）

第三章 栈和队列
栈（Stack）是仅限制在表的一端进行插入和删除运算的线性表，称插入、删除这一端为栈顶，另一端称为栈底。表中无元素时为空栈。栈的修改是按后进先出的原则进行的，我们又称栈为LIFO表（Last In First Out）
通常栈有顺序栈和链栈两种存储结构。

    在顺序栈中有“上溢”和“下溢”的现象。
    ·“上溢”是栈顶指针指出栈的外面是出错状态。
    ·“下溢”可以表示栈为空栈，因此用来作为控制转移的条件。
    顺序栈中的基本操作有六种：
    ·构造空栈
    ·判栈空
    ·判栈满
    ·进栈
    ·退栈
    ·取栈顶元素

    链栈则没有上溢的限制，因此进栈不要判栈满
    链栈不需要在头部附加头结点，只要有链表的头指针就可以了

    链栈中的基本操作有五种：
    ·构造空栈
    ·判栈空
    ·进栈
    ·退栈
    ·取栈顶元素

队列 是一种运算受限的线性表，插入在表的一端进行,而删除在表的另一端进行,允许删除的一端称为队头（front），允许插入的一端称为队尾（rear）
    .队列也有顺序存储和链式存储两种存储结构
     队列的基本运算有六种:
        ·置空队：InitQueue（Q）
        ·判队空：QueueEmpty（Q）
        ·判队满：QueueFull（Q）
        ·入队：EnQueue（Q，x）
        ·出队：DeQueue（Q）
        ·取队头元素：QueueFront（Q）

     顺序队列的“假上溢”现象：由于头尾指针不断前移，超出向量空间。这时整个向量空间及队列是空的却产生了“上 溢”现象
     队列的链式存储结构称为链队列，一个链队列就是一个操作受限的单链表。为了便于在表尾进行插入（入队）的  操作，在表尾增加一个尾指针，一个链队列就由一个头指针和一个尾指针唯一地确定。链队列不存在队满和上溢 的问题。在链队列的出队算法中，要注意当原队中只有一个结点时，出队后要同进修改头尾指针并使队列变空

多维数组
    数组一般用顺序存储的方式表示
    存储的方式有：
        ·行优先顺序，也就是把数组逐行依次排列。PASCAL、C
        ·列优先顺序，就是把数组逐列依次排列。FORTRAN

    矩阵的压缩存储：
        为多个相同的非零元素分配一个存储空间；对零元素不分配空间
        ·对称矩阵：满足a（ij）=a（ji）。

树
    1、是n个结点的有限集合，非空时必须满足：只有一个称为根的结点；其余结点形成m个不相交的子集，并称 根的子树
        根是开始结点；结点的子树数称度；度为0的结点称叶子（终端结点）；度不为0的结点称分支结点
        有序树是子树有左，右之分的树；无序树是子树没有左，右之分的树；森林是m个互不相交的树的集合

    2、二叉树的定义：是n≥0个结点的有限集，它是空集（n=0）或由一个根结点及两棵互不相交的分别称作这个根的 左子树和右子树的二叉树组成。
      二叉树的4个重要性质
        二叉树上第i层上的结点数目最多为2^（i-1）（i≥1）
        深度为k的二叉树至多有（2^k）-1个结点（k≥1）
        在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1
        具有n个结点的完全二叉树的深度为int（log2n）+1.   满二叉树是一棵深度为k，结点数为（2^k）-1的二叉树；完全二叉树是满二叉树在最下层自右向左去处部分结点；  二叉树的顺序存储结构就是把二叉树的所有结点按照层次顺序存储到连续的存储单元中。（存储前先将其画成完全 二叉树）

    3、树的存储结构多用的是链式存储
       树的存储结构多用的是链式存储。BinTNode的结构为lchild|data|rchild，把所有BinTNode类型的结点，加上一个指向根结点的BinTree型头指针就构成了二叉树的链式存储结构，称为二叉链表
       先序遍历（前序遍历或先根遍历），中序遍历（或中根遍历）、后序遍历（或 后根遍历）。时间复杂度为O（n）。
       利用二叉链表中的n+1个空指针域来存放指向某种遍历次序下的前趋结点和后继结点的指针，这些附加的指针就称为“线索”，加上线索的二叉链表就称为线索链表,线索使得查找中序前趋和中序后继变得简单有效

    4、树和森林及二叉树的转换是唯一对应的
       树变二叉树：兄弟相连，保留长子的连线。
       二叉树变树：结点的右孩子与其双亲连。
       森林变二叉树：树变二叉树，各个树的根相连。

    5、树的存储结构
        双亲链表表示法：结点data | parent，对于求指定结点的双亲或祖先十分方便，但不适于求指定结 点的孩子及后代
        孩子链表表示法：为树中每个结点data | next设置一个孩子链表firstchild，并将data | firstchild存放在一个向量中
        双亲孩子链表表示法：将双亲链表和孩子链表结合
        孩子兄弟链表表示法：结点结构leftmostchild |data | rightsibing，附加两个分别指向该结点的最左孩子和右邻兄弟的 指针域

    6、哈夫曼树是一种带权路径长度最短的二叉树，也称为最优二叉树
       哈夫曼树有n个叶结点，共有2n-1个结点，没有度为1的结点
       5、8、4、11、9、13 生成哈夫曼树
       (1) 第一步：按从小到大排序。
       (2) 选最小两个数画出一个树，最小数为4和5
           之后一直重复第一、第二步：排序然后取两个最小值

    7、满二叉树肯定是完全二叉树，完全二叉树不一定是满二叉树。
       所有的节点都有两个子节点，这类二叉树称作满二叉树
       若设二叉树的深度为h,除第 h 层外,其它各层的结点数都达到最大个数,第 h 层所有的结点都连续集中在最左边,这就是完全二叉树

    8、平衡二叉树
       AVL平衡二叉搜索树(严格平衡树)
        （1）左右子树深度之差的绝对值不超过1;
        （2）左右子树仍然为平衡二叉树.
         平衡因子BF=左子树深度－右子树深度.
         平衡二叉树每个结点的平衡因子只能是1，0，-1。若其绝对值超过1，则该二叉排序树就是不平衡的。

       RBT红黑树 : 红黑是弱平衡的，用非严格的平衡来换取增删节点时候旋转次数的降低
        1）每个结点要么是红的，要么是黑的。
        2）根结点是黑的。
        3）每个叶结点，即空结点（NIL）是黑的。
        4）如果一个结点是红的，那么它的俩个儿子都是黑的。
        5）对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。

       http://blog.csdn.net/sup_heaven/article/details/39313731

    小结:
       B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；
       B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；
       B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；
       B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率 从1/2提高到2/3；
       B+/B*Tree应用 数据库索引--索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。
       数据库索引--表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键。
       倒排索引--也可以由B树及其变种实现但不一定非要B树及其变种实现，如lucene没有使用B树结构，因此lucene可以用二分搜索算法快速定位关键词。
       实现时，lucene将下面三列分别作为词典文件（Term Dictionary）、频率文件(frequencies)、位置文件 (positions)保存。
       其中词典文件不仅保存有每个关键词，还保留了指向频率文件和位置文件的指针，通过指针可以找到该关键字的频率信息和位置信息。 　　

















