一、Servlet
1、Servlet是基于Java技术的web组件，容器(servlet引擎)托管的，用于生成动态内容。
客户端通过Servlet容器实现的请求/应答模型与Servlet交互。

2、Servlet容器
Servlet 容器是web server或application server 的一部分，提供基于请求/响应发送模型的网络服务，解码基于 MIME 的请求，并且格式化基于 MIME 的响应。
Servlet 容器也包含了管理 Servlet 生命周期
Servlet容器必须支持基于 HTTP 协议的请求/响应模型

(1)、客户端（如 web 浏览器）发送一个 HTTP 请求到 web 服务器；
(2)、 Web 服务器接收到请求并且交给 servlet 容器处理， servlet 容器可以运行在与宿主 web 服务器同一个进
程中，也可以是同一主机的不同进程，或者位于不同的主机的 web 服务器中，对请求进行处理。
(3)、 servlet 容器根据 servlet 配置选择相应的 servlet，并使用代表请求和响应对象的参数进行调用。
(4)、 servlet 通过请求对象得到远程用户， HTTP POST 参数和其他有关数据可能作为请求的一部分随请求一
起发送过来。 Servlet 执行我们编写的任意的逻辑，然后动态产生响应内容发送回客户端。发送数据到客户
端是通过响应对象完成的。
(5)、一旦 servlet 完成请求的处理， servlet 容器必须确保响应正确的刷出，并且将控制权还给宿主 Web 服务器

二、Servlet接口
Servlet接口是JavaServletAPI的核心抽象，所有Servlet类必须直接或间接的实现该接口
GenericServlet 和 HttpServlet 这两个类实现了Servlet接口。大多数情况下，开发者只需要继承 HttpServlet 去实现自己的 Servlet 即可。

1、请求处理方法
Servlet基础接口定义了用于客户端请求处理的service方法，当有请求到达时，该方法有servlet容器路由到一个servlet实例
(1) 基于Http规范的请求处理方法
HttpServlet抽象子类在Servlet接口基础上添加协议相关的方法，并且这些方法能根据HTTP请求类型自动的有HttpServlet中实现的service方法转发到相应的协议相关的处理方法

2、实例数量
(1)
如果未托管在分布式环境中（默认）的 servlet，servlet 容器对于每一个 Servlet 声明必须有且只能产生一个实例
如果 Servlet实现了SingleThreadModel接口， servlet容器可以选择实例化多个实例,以便处理高负荷请求或者串行化请求到一个特定实例。
(2)
如果 servlet 以分布式方式进行部署，容器可以为每个虚拟机（ JVM）的每个 Servlet 声明产生一个实例。
如果 servlet 实现了 SingleThreadModel接口，此时容器可以为每个容器的 JVM 实例化多个 Servlet 实例

3、Servlet生命周期
(1) 加载和实例化
Servlet容器负责加载和实例化Servlet，加载和实例化可以发生在容器启动时，或者延迟初始化直到容器决定请求需要处理时。
(2) 初始化
一旦一个Servlet对象实例化完毕，容器接下来必须在处理客户端请求之前初始化该Servlet
容器通过Servlet实例的init方法完成初始化，init方法定义在Servlet接口中
并且提供一个唯一的ServletConfig接口实现的对象作为参数，该对象每个Servlet实例一个
ServletConfig允许Servlet访问有web应用配置信息提供的key-value的初始化参数
(3) 处理请求
Servlet完成初始化后，Servlet容器就可以使用它处理客户端请求了。
客户端请求由 ServletRequest 类型的
request 对象表示。 Servlet 封装响应并返回给请求的客户端，该响应由 ServletResponse 类型的 response 对象
表示。这两个对象（ request 和 response）是由容器通过参数传递到 Servlet 接口的service方法的
1 多线程问题:
Servlet容器可以并发的发送多个请求到Servlet的service方法。为了处理这些请求，Servlet开发者必须为service方法的多线程并发处理做好准备
方案一：实现SingleThreadModel接口，保证一个service方法在同一个时间点仅被一个请求线程调用
方案二：Servlet容器可以通过串行化访问Servlet的请求，或者维护一个Servlet实例池

2 请求处理时的异常（ServletException 或 UnavailableException ）
Servlet容器必须从服务中移除这个Servlet,调用它的destory方法

3 异步处理
Filter及Servlet生成响应之前必须等待一些资源或事件来完成请求处理
Servlet3引入了异步处理请求的能力，使线程可以返回容器，从而执行更多的任务。
4 线程安全

(4) 终止服务
当Servlet容器确定servlet应该从服务中移除时，将调用Servlet接口的destory方法。

三、Request
请求对象封装了客户端请求的所有信息，在Http协议中，这些信息是从客户端发送到服务器请求的HTTP头不和信息体

1、Http协议参数
servlet的请参数以字符串的形式作为请求的一部分从客户端发送到servlet容器。
ServletRequest接口
getParameter、getParameterNames、getParameterValues、getParameterMap

2、文件上传：当数据以 multipart/form-data 的格式发送时， servlet 容器支持文件上传

3 属性
属性是与请求相关联的对象
属性可以由容器设置来表达信息，或者有servlet设置将信息传达给另一个servlet。
属性通过ServletRequest接口中下面的方法来访问 getAttribute、getAttributeNames、setAttribute

4 头
servlet可以通过HttpServletRequest接口访问HTTP请求头部信息：getHeader、getHeaders、getHeaderNames

5 请求路径元素
getContextPath：
getServletPath:
getPathInfo:

6 路径转换方法
getRealPath 方法需要一个字符串参数，并返回一个字符串形式的路径，这个路径对应一个在本地文件系统
上的文件。 getPathTranslated 方法推断出请求的 pathInfo 的实际路径

7 非阻塞IO
servlet容器的非阻塞 IO 允许开发人员在数据可用时读取数据或在数据可写时写数据

8 Cookies
HttpServletRequest 接口提供了 getCookies 方法来获得请求中的 cookie 的一个数组。这些 cookie 是从客户端
发送到服务器端的客户端发出的每个请求上的数据

9 SSL属性
如果请求已经通过一个安全协议发送过，如 HTTPS，必须通过 ServletRequest 接口的 isSecure 方法公开该信
息

10 国际化
客户端可以选择希望 Web 服务器用什么语言来响应。该信息可以和使用 Accept-Language 头与 HTTP/1.1 规范
中描述的其他机制的客户端通信。 ServletRequest 接口提供下面的方法来确定发送者的首选语言环境：
getLocale和getLocales

11 请求数据编码
12 Request对象的生命周期

四 Servlet Context
1 servletContext接口
servletContext接口定义了servlet运行在的web应用的视图
ServletContext 是 Web 服务器中已知路径的根。例如， Servlet 上下文可以从 http://www.mycorp.com/catalog
找出， /catalog 请求路径称为上下文路径，所有以它开头的请求都会被路由到与 ServletContext 相关联的Web 应用

2 servletContext接口作用范围
每一个部署到容器的web应用都有一个servlet接口的实例与之关联

3 初始化参数
ServletContext 接口方法允许 Servlet 访问由应用开发人员在 Web 应用中的部署描述符中指定的上下文初始化参数
getInitParameter
getInitParameterNames

4 配置方式：web.xml或编程方式定义

5 上下文属性
Servlet 可以使用指定的名字将对象属性绑定到上下文。同一个 Web 应用内的其他任何 Servlet 都可以使用绑定到上下文的任意属性
分布式容器中的上下文属性
在 JVM 中创建的上下文属性是本地的，这可以防止从一个分布式容器的共享内存存储中获取 ServletContext
属性。当需要在运行在分布式环境的 Servlet 之间共享信息时，该信息应该被放到 session（请看第 7 章，“会
话”），或存储到数据库，或者设置到企业级 JavaBean 组件（ Enterprise JavaBeans™）。

6 资源 :ServletContext 接口提供了直接访问 Web 应用中静态内容层次结构的文件的方法
getResource
getResourceAsStream

7 多主机和Servlet上下文
Web 服务器可以支持多个逻辑主机共享一个服务器 IP 地址,每一个逻辑主机必须有它自己的上下文或一组上下文。 Servlet 上下文不会在虚拟主机之间共享

8 Reload 重新加载

五、Response响应
响应（ response）对象封装了从服务器返回到客户端的所有信息。在 HTTP 协议中，从服务器传输到客户端的信息通过 HTTP 头信息或响应的消息体

Servlet容器允许但不必为了提高效率而缓冲到客户端的输出。

5.1 缓冲
Servlet 容器允许提高效率而缓冲到客户端的输出
ServletResponse 接口的如下方法允许servlet访问和设置缓冲信息：
getBufferSize,setBufferSize,isCommitted,reset,resetBuffer,flushBuffer

5.2 头信息
Servlet 可以使用如下 HttpServletResponse 接口中的方法设置 HTTP 响应头 setHeader,addHeader

5.3 非阻塞IO

5.4 重定向
sendRedirect 方法将设置适当的 header 和内容体将客户端重定向到另一个地址
sendError 方法将设置适当的 header 和内容体用于返回给客户端返回错误消息

5.5 结束响应对象
当响应被关闭时，容器必须立即刷出响应缓冲区中的所有剩余的内容到客户端

5.7 Response 的生命周期
每个响应对象是只有当在servlet的service 方法的范围内或在 filter 的 doFilter 方法范围内是有效的

六、Filter过滤器
1、过滤器使用
(1)在执行请求之前访问资源
(2)在执行请求之前处理资源的请求
(3)用请求对象的自定义版本包装请求对请求的 header 和数据进行修改
(4)用响应对象的自定义版本包装响应对响应的 header 和数据进行修改
(5)拦截资源调用之后的调用
(6) 作用在 Servlet，一组 Servlet，或静态内容上的零个，一个或多个拦截器按指定的顺序执行
实现 javax.servlet.Filter 接口并提供一个公共的空参构造器来创建过滤器。该类及构建Web 应用的静态资源和 Servlet 打包在 Web 应用归档文件中。
Filter 在部署描述符中通过<filter>元素声明。一个过滤器或一组过滤器可以通过在部署描述符中定义<filter-mapping>来为调用配置。
可以使用 servlet 的逻辑视图名把过滤器映射到一个特定的 servlet，或者使用 URL 模式把一组 Servlet 和静态内容资源映射到过滤器

2、过滤器的生命周期在
Web 应用部署之后，在请求导致容器访问 Web 资源之前，容器必须找到过滤器列表并按照如上所述的应用到 Web 资源。
容器必须确保它为过滤器列表中的每一个都实例化了一个适当类的过滤器,并调用其init(FilterConfig config)方法

在部署描述符中声明的每个<filter>在每个 JVM 的容器中仅实例化一个实例。容器提供了声明在过滤器的部署描述符的过滤器 config（译者注： FilterConfig），
对 Web 应用的 ServletContext 的引用，和一组初始化参数。
执行过程： Filter1.doFilter->Filter2.doFilter-> servlet.service

3、过滤器的核心概念是包装请求或响应，以便它可以覆盖行为执行过滤任务


七、会话
超文本传输协议（ HTTP）被设计为一种无状态协议
定义了一个简单的 HttpSession 接口，允许 servlet 容器使用几种方法来跟踪用户会话

1、会话跟踪机制
(1) Cookies
通过 HTTP cookie的会话跟踪是最常用的会话跟踪机制，且所有 servlet 容器都应该支持。
容器向客户端发送一个 cookie，客户端后续到服务器的请求都将返回该 cookie，明确地将请求与会话关联

(2) SSL会话
安全套接字，在HTTPS使用加密技术，有一种内置机制允许多个来自客户端的请求被明确识别为同一会话

(3) URL重写(URL工具条会暴露信息)
当客户端不接受 cookie 时，服务器可使用 URL 重写作为会话跟踪的基础。
URL 重写涉及添加数据、会话 ID、容器解析 URL 路径从而请求与会话相关联

2、创建会话:当会话跟踪信息返回到服务器指示会话已经建立时客户端加入到会话
每个会话相关联是一个包含唯一标识符的字符串，也被称为会话 ID。会话 ID 的值能通过调用
javax.servlet.http.HttpSession.getId() 获 取 ， 且 能 在 创 建 后 通 过 调 用
javax.servlet.http.HttpServletRequest.changeSessionId()改变。

3、会话范围
HttpSession 对象必须被限定在应用（或 servlet上下文）级别。不能在上下文

4 Session属性
servlet 可以按名称绑定对象属性到 HttpSession 实现，任何绑定到会话的对象可用于任意其他的 Servlet，其
属于同一个 ServletContext 且处理属于相同会话中的请求

5 会话超时
servlet 容器定义了默认的会话超时时间，且可以通过 HttpSession 接口的 getMaxInactiveInterval 方法获取。
开发人员可以使用 HttpSession 接口的 setMaxInactiveInterval 方法改变超时时间

6 最后访问时间
HttpSession 接口的 getLastAccessedTime 方法允许 servlet 确定在当前请求之前的会话的最后访问时间

7 重要的会话语义
(1) 容器必须确保，以一种线程安全的方式维护表示会话属性的内部数据结构。
(2) 分布式
在一个标识为分布式的应用程序中，会话中的所有请求在同一时间必须仅被一个JVM 处理。
容器必须能够使用适当的 setAttribute 或 putValue 方法把所有对象放入到 HttpSession 类实例

八、分派请求
构建 Web 应用时，把请求转发给另一个 servlet 处理、或在 response 中包含另一个 servlet 的输出通常是很有
用的。 RequestDispatcher 接口提供了一种机制来实现这种功能

1 获得一个RequestDispather
ServletContext 和 ServletRequest 中创建 RequestDispatcher 对象的方法使用的路径信息中允许附加可选的查
询字符串信息

2 请求调度器的使用
servlet 可调用 RequestDispatcher 接口的 include 或 forward 方法

3 include方法
RequestDispatcher 接口的 include 方法可能随时被调用

4 forward方法
RequestDispatcher接口的 forward 方法，只有在没有输出提交到向客户端时，通过正在被调用的servlet调用

5 异步上下文对象
实现了 AsyncContext 接口的对象可从 ServletRequest 的一个 startAsync 方法中获得，一旦有了 AsyncContext78
对象，你就能够使用它的 complete()方法来完成请求处理，或使用下面描述的转发方法

6 Dispatch方法:可以使用 AsyncContext 中下面的方法来转发请求：dispatch







