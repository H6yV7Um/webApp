状态变化的使用场景： 从节点需要知道主要主节点挂掉，从节点需要知道任务分配给了自己，Zookeeper的客户端定时轮询Zookeeper集群状态。避免轮询的方式是，使用监听点，通过监听点，客户端可以对指定的znode节点注册一个通知请求，在发生变化时就会收到一个通知。

一、单次触发器（监视点 ）： 只会触发一次事件
1、监视点可以跨越不同服务端的连接而保持，当一个客户端与zookeeper服务端的连接断开后连接到集群中的另一个服务端，客户端会发送未触发的监视点列表。在注册监视点时，服务端将要检查以监视的znode节点在之前监视点再之后是否变化，如果znode节点已经发生变化，一个监视点的事件会被发送给客户端，否则再新的服务端上注册监视点。

2、单次触发是否会丢失事件 ：不会带来影响，因为任何在接受通知与注册新监视点之间的变化情况，可以通过zookeeper的状态信息来获得。

二、如何设置监视点 ：监视点有两种类型，数据监视点和子节点监视点。
1、创建、删除或设置一个znode节点的数据都会触发数据监视点，exists 和 getData 这两个操作可以设置数据监视点。
2、只有getChildren 操作可以设置子节点和监视点。
对于zookeeper节点的事件的通知，可以使用默认的监视点，也可以单独实现。
3、监视点存在一个问题，一旦设置监视点就无法移除。

三、普遍模型
1、通用代码的模式
(1) 进行调用异步
zk.exists("/myZnode",myWatcher,existsCallback,null);

(2) watcher 实现
Watcher myWatcher = new Watcher（）{
   public void process(WatccherEvent e){}
}
(3) 回调函数
StatCallback existCallback = new  StatCallback(){
   public void processResult(int rc,String path,Object ctx,Stat stat){}
}


四、主－从模式的例子

五、multiop 调用方式 ： 可以原子性地执行多个Zookeeper的操作

六、通过监视点替代显式缓存管理 ： 监视点可以让客户端在本地缓存一个版本的数据，并在数据发生变化时接受到通知来进行更新。

七、zookeeper （集群中所有服务器）顺序的保障
写操作的顺序 ： 对集群中一台服务器对的状态修改顺序，其他服务器的状态也会按照同样的顺利修改。
读操作的顺序 ：  客户端会观察到相同的更新顺序。
通知顺利

注意： 避免在一个节点设置大量的监视点，因为设置大量监视点，这个节点会产生尖峰通知。